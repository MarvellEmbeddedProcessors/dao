From 34a29a065e1728941f633706ea7abee71aef3903 Mon Sep 17 00:00:00 2001
From: Varun Rapelly <vrapelly@marvell.com>
Date: Tue, 23 Jul 2024 05:11:41 +0000
Subject: [PATCH] asynchronous support

This patch provides an extended Nginx working with asynchronous
mode OpenSSL. With Octeon CPT acceleration, Asynch Mode NGINX can
provide significant performance improvement.

Signed-off-by: Varun Rapelly <vrapelly@marvell.com>
---
 auto/cc/gcc                                   |    9 +-
 auto/make                                     |    2 +
 auto/modules                                  |    9 +-
 auto/sources                                  |   15 +-
 conf/nginx.conf                               |    2 +
 configure                                     |  116 ++
 modules/nginx_cpt_module/README               |  160 +++
 modules/nginx_cpt_module/config               |   15 +
 .../ngx_ssl_engine_cpt_module.c               | 1212 +++++++++++++++++
 src/core/nginx.c                              |   10 +
 src/core/ngx_buf.h                            |    3 +-
 src/core/ngx_conf_file.h                      |    8 +
 src/core/ngx_connection.c                     |   84 +-
 src/core/ngx_connection.h                     |   13 +-
 src/core/ngx_cycle.c                          |    4 +
 src/core/ngx_cycle.h                          |    5 +
 src/core/ngx_resolver.c                       |    7 +
 src/core/ngx_string.h                         |   14 +-
 .../modules/ngx_ssl_engine_dasync_module.c    |  236 ++++
 src/engine/ngx_ssl_engine.c                   |  547 ++++++++
 src/engine/ngx_ssl_engine.h                   |  102 ++
 src/event/modules/ngx_devpoll_module.c        |    3 +
 src/event/modules/ngx_epoll_module.c          |  287 +++-
 src/event/modules/ngx_eventport_module.c      |    3 +
 src/event/modules/ngx_iocp_module.c           |    4 +-
 src/event/modules/ngx_kqueue_module.c         |   84 +-
 src/event/modules/ngx_poll_module.c           |    5 +-
 src/event/modules/ngx_select_module.c         |    5 +-
 src/event/modules/ngx_win32_select_module.c   |    5 +-
 src/event/ngx_event.c                         |   28 +-
 src/event/ngx_event.h                         |   22 +
 src/event/ngx_event_accept.c                  |   22 +
 src/event/ngx_event_connect.c                 |    4 +
 src/event/ngx_event_openssl.c                 |  756 ++++++++--
 src/event/ngx_event_openssl.h                 |   11 +-
 src/event/ngx_event_timer.c                   |    2 +
 src/http/modules/ngx_http_grpc_module.c       |   18 +
 src/http/modules/ngx_http_proxy_module.c      |   18 +
 src/http/modules/ngx_http_ssl_module.c        |   87 ++
 src/http/modules/ngx_http_ssl_module.h        |    6 +
 .../ngx_http_upstream_keepalive_module.c      |   12 +
 src/http/ngx_http.c                           |    6 +
 src/http/ngx_http_core_module.c               |   14 +
 src/http/ngx_http_core_module.h               |    3 +
 src/http/ngx_http_request.c                   |  151 +-
 src/http/ngx_http_upstream.c                  |   61 +-
 src/http/ngx_http_upstream.h                  |    2 +
 src/mail/ngx_mail.c                           |    3 +
 src/mail/ngx_mail.h                           |    3 +
 src/mail/ngx_mail_core_module.c               |   18 +
 src/mail/ngx_mail_handler.c                   |    4 +
 src/mail/ngx_mail_ssl_module.c                |   42 +-
 src/mail/ngx_mail_ssl_module.h                |    2 +
 src/os/unix/ngx_process_cycle.c               |   57 +-
 src/stream/ngx_stream.c                       |    7 +-
 src/stream/ngx_stream.h                       |    8 +-
 src/stream/ngx_stream_core_module.c           |   23 +
 src/stream/ngx_stream_handler.c               |   14 +-
 src/stream/ngx_stream_proxy_module.c          |   21 +
 src/stream/ngx_stream_ssl_module.c            |   14 +
 src/stream/ngx_stream_ssl_module.h            |    3 +
 62 files changed, 4241 insertions(+), 238 deletions(-)
 create mode 100755 configure
 create mode 100644 modules/nginx_cpt_module/README
 create mode 100644 modules/nginx_cpt_module/config
 create mode 100644 modules/nginx_cpt_module/ngx_ssl_engine_cpt_module.c
 create mode 100644 src/engine/modules/ngx_ssl_engine_dasync_module.c
 create mode 100644 src/engine/ngx_ssl_engine.c
 create mode 100644 src/engine/ngx_ssl_engine.h

diff --git a/auto/cc/gcc b/auto/cc/gcc
index a5c5c18fb..3a8f5f514 100644
--- a/auto/cc/gcc
+++ b/auto/cc/gcc
@@ -1,6 +1,7 @@

 # Copyright (C) Igor Sysoev
 # Copyright (C) Nginx, Inc.
+# Copyright (C) Intel, Inc.


 # gcc 2.7.2.3, 2.8.1, 2.95.4, egcs-1.1.2
@@ -48,9 +49,9 @@ esac

 # optimizations

-#NGX_GCC_OPT="-O2"
+NGX_GCC_OPT="-O2 -D_FORTIFY_SOURCE=2 -fno-strict-overflow -fno-delete-null-pointer-checks -fwrapv"
 #NGX_GCC_OPT="-Os"
-NGX_GCC_OPT="-O"
+#NGX_GCC_OPT="-O"

 #CFLAGS="$CFLAGS -fomit-frame-pointer"

@@ -174,6 +175,10 @@ CFLAGS="$CFLAGS -g"
 # DragonFly's gcc3 generates DWARF
 #CFLAGS="$CFLAGS -g -gstabs"

+# required by Intel SDL
+CFLAGS="$CFLAGS -fstack-protector -fPIE -fPIC -Wformat -Wformat-security"
+CORE_LINK="-z noexecstack -z relro -z now -pie"
+
 if [ ".$CPP" = "." ]; then
     CPP="$CC -E"
 fi
diff --git a/auto/make b/auto/make
index ef7c9f694..4bfe9698d 100644
--- a/auto/make
+++ b/auto/make
@@ -1,11 +1,13 @@

 # Copyright (C) Igor Sysoev
 # Copyright (C) Nginx, Inc.
+# Copyright (C) Intel, Inc.


 echo "creating $NGX_MAKEFILE"

 mkdir -p $NGX_OBJS/src/core $NGX_OBJS/src/event $NGX_OBJS/src/event/modules \
+         $NGX_OBJS/src/engine $NGX_OBJS/src/engine/modules \
          $NGX_OBJS/src/os/unix $NGX_OBJS/src/os/win32 \
          $NGX_OBJS/src/http $NGX_OBJS/src/http/v2 $NGX_OBJS/src/http/modules \
          $NGX_OBJS/src/http/modules/perl \
diff --git a/auto/modules b/auto/modules
index 94867bfc0..de1f0190a 100644
--- a/auto/modules
+++ b/auto/modules
@@ -1,6 +1,7 @@

 # Copyright (C) Igor Sysoev
 # Copyright (C) Nginx, Inc.
+# Copyright (C) Intel, Inc.


 if [ $EVENT_SELECT = NO -a $EVENT_FOUND = NO ]; then
@@ -56,6 +57,10 @@ if [ $NGX_TEST_BUILD_SOLARIS_SENDFILEV = YES ]; then
 fi


+SSL_ENGINE_MODULES="$SSL_ENGINE_MODULES $DASYNC_ENGINE_MODULE"
+CORE_SRCS="$CORE_SRCS $DASYNC_ENGINE_SRCS"
+
+
 if [ $HTTP = YES ]; then
     HTTP_MODULES=
     HTTP_DEPS=
@@ -1259,7 +1264,7 @@ fi

 if [ $USE_OPENSSL = YES ]; then
     ngx_module_type=CORE
-    ngx_module_name=ngx_openssl_module
+    ngx_module_name=
     ngx_module_incs=
     ngx_module_deps=src/event/ngx_event_openssl.h
     ngx_module_srcs="src/event/ngx_event_openssl.c
@@ -1286,7 +1291,7 @@ if [ $USE_PCRE = YES ]; then
 fi


-modules="$CORE_MODULES $EVENT_MODULES"
+modules="$CORE_MODULES $EVENT_MODULES $SSL_ENGINE_MODULES"


 # thread pool module should be initialized after events
diff --git a/auto/sources b/auto/sources
index 156f7979e..aa231fd2a 100644
--- a/auto/sources
+++ b/auto/sources
@@ -1,6 +1,7 @@

 # Copyright (C) Igor Sysoev
 # Copyright (C) Nginx, Inc.
+# Copyright (C) Intel, Inc.


 CORE_MODULES="ngx_core_module ngx_errlog_module ngx_conf_module"
@@ -123,12 +124,20 @@ EPOLL_SRCS=src/event/modules/ngx_epoll_module.c
 IOCP_MODULE=ngx_iocp_module
 IOCP_SRCS=src/event/modules/ngx_iocp_module.c

+SSL_ENGINE_MODULES="ngx_ssl_engine_module ngx_ssl_engine_core_module"
+SSL_ENGINE_INCS="src/engine src/engine/modules"
+SSL_ENGINE_DEPS="src/engine/ngx_ssl_engine.h"
+SSL_ENGINE_SRCS="src/engine/ngx_ssl_engine.c"
+
+DASYNC_ENGINE_MODULE=ngx_ssl_engine_dasync_module
+DASYNC_ENGINE_SRCS=src/engine/modules/ngx_ssl_engine_dasync_module.c
+
 FILE_AIO_SRCS="src/os/unix/ngx_file_aio_read.c"
 LINUX_AIO_SRCS="src/os/unix/ngx_linux_aio_read.c"

-UNIX_INCS="$CORE_INCS $EVENT_INCS src/os/unix"
+UNIX_INCS="$CORE_INCS $EVENT_INCS $SSL_ENGINE_INCS src/os/unix"

-UNIX_DEPS="$CORE_DEPS $EVENT_DEPS \
+UNIX_DEPS="$CORE_DEPS $EVENT_DEPS $SSL_ENGINE_DEPS \
             src/os/unix/ngx_time.h \
             src/os/unix/ngx_errno.h \
             src/os/unix/ngx_alloc.h \
@@ -157,7 +166,7 @@ UNIX_DEPS="$CORE_DEPS $EVENT_DEPS \
 #            src/os/unix/ngx_sunpro_sparc64.il \


-UNIX_SRCS="$CORE_SRCS $EVENT_SRCS \
+UNIX_SRCS="$CORE_SRCS $EVENT_SRCS $SSL_ENGINE_SRCS \
             src/os/unix/ngx_time.c \
             src/os/unix/ngx_errno.c \
             src/os/unix/ngx_alloc.c \
diff --git a/conf/nginx.conf b/conf/nginx.conf
index 29bc085f2..b4448cb70 100644
--- a/conf/nginx.conf
+++ b/conf/nginx.conf
@@ -99,6 +99,8 @@ http {
     #    listen       443 ssl;
     #    server_name  localhost;

+    #    ssl_protocols       TLSv1.2;
+
     #    ssl_certificate      cert.pem;
     #    ssl_certificate_key  cert.key;

diff --git a/configure b/configure
new file mode 100755
index 000000000..7e6e33a7c
--- /dev/null
+++ b/configure
@@ -0,0 +1,116 @@
+#!/bin/sh
+
+# Copyright (C) Igor Sysoev
+# Copyright (C) Nginx, Inc.
+
+
+LC_ALL=C
+export LC_ALL
+
+. auto/options
+. auto/init
+. auto/sources
+
+test -d $NGX_OBJS || mkdir -p $NGX_OBJS
+
+echo > $NGX_AUTO_HEADERS_H
+echo > $NGX_AUTOCONF_ERR
+
+echo "#define NGX_CONFIGURE \"$NGX_CONFIGURE\"" > $NGX_AUTO_CONFIG_H
+
+
+if [ $NGX_DEBUG = YES ]; then
+    have=NGX_DEBUG . auto/have
+fi
+
+
+if test -z "$NGX_PLATFORM"; then
+    echo "checking for OS"
+
+    NGX_SYSTEM=`uname -s 2>/dev/null`
+    NGX_RELEASE=`uname -r 2>/dev/null`
+    NGX_MACHINE=`uname -m 2>/dev/null`
+
+    echo " + $NGX_SYSTEM $NGX_RELEASE $NGX_MACHINE"
+
+    NGX_PLATFORM="$NGX_SYSTEM:$NGX_RELEASE:$NGX_MACHINE";
+
+    case "$NGX_SYSTEM" in
+        MINGW32_* | MINGW64_* | MSYS_*)
+            NGX_PLATFORM=win32
+        ;;
+    esac
+
+else
+    echo "building for $NGX_PLATFORM"
+    NGX_SYSTEM=$NGX_PLATFORM
+fi
+
+. auto/cc/conf
+
+if [ "$NGX_PLATFORM" != win32 ]; then
+    . auto/headers
+fi
+
+. auto/os/conf
+
+if [ "$NGX_PLATFORM" != win32 ]; then
+    . auto/unix
+fi
+
+. auto/threads
+. auto/modules
+. auto/lib/conf
+
+case ".$NGX_PREFIX" in
+    .)
+        NGX_PREFIX=${NGX_PREFIX:-/usr/local/nginx}
+        have=NGX_PREFIX value="\"$NGX_PREFIX/\"" . auto/define
+    ;;
+
+    .!)
+        NGX_PREFIX=
+    ;;
+
+    *)
+        have=NGX_PREFIX value="\"$NGX_PREFIX/\"" . auto/define
+    ;;
+esac
+
+if [ ".$NGX_CONF_PREFIX" != "." ]; then
+    have=NGX_CONF_PREFIX value="\"$NGX_CONF_PREFIX/\"" . auto/define
+fi
+
+have=NGX_SBIN_PATH value="\"$NGX_SBIN_PATH\"" . auto/define
+have=NGX_CONF_PATH value="\"$NGX_CONF_PATH\"" . auto/define
+have=NGX_PID_PATH value="\"$NGX_PID_PATH\"" . auto/define
+have=NGX_LOCK_PATH value="\"$NGX_LOCK_PATH\"" . auto/define
+have=NGX_ERROR_LOG_PATH value="\"$NGX_ERROR_LOG_PATH\"" . auto/define
+
+have=NGX_HTTP_LOG_PATH value="\"$NGX_HTTP_LOG_PATH\"" . auto/define
+have=NGX_HTTP_CLIENT_TEMP_PATH value="\"$NGX_HTTP_CLIENT_TEMP_PATH\""
+. auto/define
+have=NGX_HTTP_PROXY_TEMP_PATH value="\"$NGX_HTTP_PROXY_TEMP_PATH\""
+. auto/define
+have=NGX_HTTP_FASTCGI_TEMP_PATH value="\"$NGX_HTTP_FASTCGI_TEMP_PATH\""
+. auto/define
+have=NGX_HTTP_UWSGI_TEMP_PATH value="\"$NGX_HTTP_UWSGI_TEMP_PATH\""
+. auto/define
+have=NGX_HTTP_SCGI_TEMP_PATH value="\"$NGX_HTTP_SCGI_TEMP_PATH\""
+. auto/define
+
+. auto/make
+. auto/lib/make
+. auto/install
+
+# STUB
+. auto/stubs
+
+have=NGX_USER value="\"$NGX_USER\"" . auto/define
+have=NGX_GROUP value="\"$NGX_GROUP\"" . auto/define
+
+if [ ".$NGX_BUILD" != "." ]; then
+    have=NGX_BUILD value="\"$NGX_BUILD\"" . auto/define
+fi
+
+. auto/summary
diff --git a/modules/nginx_cpt_module/README b/modules/nginx_cpt_module/README
new file mode 100644
index 000000000..af125678e
--- /dev/null
+++ b/modules/nginx_cpt_module/README
@@ -0,0 +1,160 @@
+# Copyright (C) Intel, Inc.
+
+This module is developed of QAT engine in Nginx engine framework.
+
+
+Installation
+
+1. Add below configuration line into the config.example
+    --add-dynamic-module=modules/nginx_qat_module/
+2. Build Nginx with the addon modules
+    $ ./config.example
+    $ make && make install
+
+
+Configuration
+
+1. Add dynamic loading configuration in nginx.conf
+    $ load_module modules/ngx_ssl_engine_qat_module.so;
+
+2. Using ssl_engine block to configure QAT engine
+    ssl_engine {
+        use_engine qatengine;
+        default_algorithms ALL;
+        qat_engine {
+            #qat_offload_mode async;
+            #qat_notify_mode poll;
+
+            #qat_poll_mode internal;
+            #qat_internal_poll_interval 10000;
+
+            #qat_poll_mode external;
+            #qat_external_poll_interval 1;
+
+            qat_poll_mode heuristic;
+        }
+    }
+
+
+Directives
+
+    Syntax:     qat_sw_fallback on | off;
+    Default:    off
+    Dependency: This feature only supports AES128-SHA, DHE-DSS-AES256-SHA256,
+                ECDHE-ECDSA-AES128-SHA256, ECDHE-RSA-AES128-SHA for TLS1.2.
+    Description:
+                If QAT enabled software fallback mode, the qat engine would
+                switch to software mode instead of stays in hardware while
+                malfunction.
+
+    Syntax:     qat_offload_mode async | sync;
+    Default:    async
+    Dependency: Consistent with the use of "ssl_asynch" directive
+    Description:
+                Synchronous or Asynchronous mode
+
+    Syntax:     qat_notify_mode event | poll;
+    Default:    poll
+    Dependency: N/A
+    Description:
+                QAT engine uses event driven polling feature or not
+
+    Syntax:     qat_poll_mode inline | internal | external | heuristic;
+    Default:    internal
+    Dependency: N/A
+    Description:
+                Different kinds of polling mode to check for messages from the
+                hardware accelerator
+                * inline: a busy loop is used, currently only available in the
+                synchronous RSA computation
+                * internal: a internal polling thread is created by QAT engine
+                * external: a timer-based polling is employed in each Nginx
+                worker process
+                * heuristic: an improvement of the external polling mode,
+                leveraging the application knowledge to intelligently determine
+                the proper polling moment
+
+    Syntax:     qat_shutting_down_release on | off;
+    Default:    off
+    Dependency: Work with offloading all supported algorithms except CIPHERS
+                qat_poll_mode must be set before this directive and only external
+                polling and heuristic polling mode are acceptable
+    Description:
+                QAT instance will be released when worker is in shutting down
+                state if this directive is set to 'on'. This directive is designed
+                for the keep-alive connection who is completed SSL handshake and
+                waiting for more HTTP commands. To support more flexiable 'reload'
+                operation, QAT instance is released from such kind of connection.
+                Currently this feature is not supported when CIPHERS are offloaded
+                to QAT.
+
+    Syntax:     qat_internal_poll_interval time;
+    Default:    10000
+    Dependency: Valid if (qat_poll_mode=internal)
+    Description:
+                Internal polling time interval (ns)
+                Valid value: 1 ~ 10000000
+
+    Syntax:     qat_external_poll_interval time;
+    Default:    1
+    Dependency: Valid if (qat_poll_mode=external)
+    Description:
+                External polling time interval (ms)
+                Valid value: 1 ~ 1000
+
+    Syntax:     qat_heuristic_poll_asym_threshold num;
+    Default:    48
+    Dependency: Valid if (qat_poll_mode=heuristic)
+    Description:
+                Threshold of the number of in-flight requests to trigger a
+                polling operation when there are in-flight asymmetric
+                crypto requests
+                Valid value: 1 ~ 512
+
+
+    Syntax:     qat_heuristic_poll_sym_threshold num;
+    Default:    24
+    Dependency: Valid if (qat_poll_mode=heuristic)
+    Description:
+                Threshold of the number of in-flight requests to trigger a
+                polling operation when there is no in-flight asymmetric
+                crypto request
+                Valid value: 1 ~ 512
+
+    Syntax:     qat_small_pkt_offload_threshold string ...;
+    Default:    2048
+    Dependency: Valid if cipher is offloaded
+    Description:
+                The input is the string of cipher algorithm name and
+                threshold value. Please refer to the README of QAT engine.
+                Example input:
+                    2048
+                    AES-128-CBC-HMAC-SHA1:4096
+                    AES-128-CBC-HMAC-SHA1:4096 AES-256-CBC-HMAC-SHA1:8192
+
+
+Note
+
+    1. Not all the combinations of offload mode, notify mode and poll mode are
+    valid. Please refer to the following tables to check the validity.
+
+    +-------+--------+----------+----------+-----------+
+    | sync  | inline | internal | external | heuristic |
+    +-------+--------+----------+----------+-----------+
+    | event |    N   |     Y    |     N    |     N     |
+    +-------+--------+----------+----------+-----------+
+    | poll  |    Y   |     Y    |     N    |     N     |
+    +-------+--------+----------+----------+-----------+
+
+    +-------+--------+----------+----------+-----------+
+    | async | inline | internal | external | heuristic |
+    +-------+--------+----------+----------+-----------+
+    | event |    N   |     Y    |     N    |     N     |
+    +-------+--------+----------+----------+-----------+
+    | poll  |    N   |     Y    |     Y    |     Y     |
+    +-------+--------+----------+----------+-----------+
+
+
+    2. Changing polling mode will not be effective until Nginx restart. It is
+    not possible to change the polling mode via soft restart, such as
+    'nginx -s reload' or 'kill -HUP [master-pid]'
diff --git a/modules/nginx_cpt_module/config b/modules/nginx_cpt_module/config
new file mode 100644
index 000000000..6f68f3001
--- /dev/null
+++ b/modules/nginx_cpt_module/config
@@ -0,0 +1,15 @@
+# Copyright (C) Intel, Inc.
+
+ngx_addon_name=ngx_ssl_engine_cpt_module
+
+if test -n "$ngx_module_link"; then
+    ngx_module_type=ENGINE
+    ngx_module_name=ngx_ssl_engine_cpt_module
+    ngx_module_srcs="$ngx_addon_dir/ngx_ssl_engine_cpt_module.c"
+
+    . auto/module
+else
+    SSL_ENGINE_MODULES="$SSL_ENGINE_MODULES ngx_ssl_engine_cpt_module"
+    NGX_ADDON_SRCS="$NGX_ADDON_SRCS $ngx_addon_dir/ngx_ssl_engine_cpt_module.c"
+fi
+
diff --git a/modules/nginx_cpt_module/ngx_ssl_engine_cpt_module.c b/modules/nginx_cpt_module/ngx_ssl_engine_cpt_module.c
new file mode 100644
index 000000000..062ade886
--- /dev/null
+++ b/modules/nginx_cpt_module/ngx_ssl_engine_cpt_module.c
@@ -0,0 +1,1212 @@
+/* ====================================================================
+ *
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2016-2021 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ * ====================================================================
+ */
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+#include <ngx_ssl_engine.h>
+
+
+typedef struct {
+    ngx_str_t       engine_id;
+    /* if this engine can be released during worker is shutting down */
+    ngx_flag_t      releasable;
+
+    ngx_flag_t      enable_sw_fallback;
+    /* sync or async (default) */
+    ngx_str_t       offload_mode;
+
+    /* event or poll (default) */
+    ngx_str_t       notify_mode;
+
+    /* inline, internal (default), external or heuristic */
+    ngx_str_t       poll_mode;
+
+    /* xxx ns */
+    ngx_int_t       internal_poll_interval;
+
+    /* xxx ms */
+    ngx_int_t       external_poll_interval;
+
+    ngx_int_t       heuristic_poll_asym_threshold;
+
+    ngx_int_t       heuristic_poll_sym_threshold;
+
+    ngx_int_t       heuristic_poll_asym_multibuff_threshold;
+
+    ngx_int_t       heuristic_poll_sym_multibuff_threshold;
+
+    ngx_array_t    *small_pkt_offload_threshold;
+} ngx_ssl_engine_cpt_conf_t;
+
+
+static ngx_int_t ngx_ssl_engine_cpt_init(ngx_cycle_t *cycle);
+static ngx_int_t ngx_ssl_engine_cpt_send_ctrl(ngx_cycle_t *cycle);
+static ngx_int_t ngx_ssl_engine_cpt_register_handler(ngx_cycle_t *cycle);
+static ngx_int_t ngx_ssl_engine_cpt_release(ngx_cycle_t *cycle);
+static void ngx_ssl_engine_cpt_heuristic_poll(ngx_log_t *log);
+
+static char *ngx_ssl_engine_cpt_block(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static char *ngx_ssl_engine_cpt_set_threshold(ngx_conf_t *cf,
+    ngx_command_t *cmd, void *conf);
+
+static void *ngx_ssl_engine_cpt_create_conf(ngx_cycle_t *cycle);
+static char *
+ngx_ssl_engine_cpt_releasable(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+static char *ngx_ssl_engine_cpt_init_conf(ngx_cycle_t *cycle, void *conf);
+
+static ngx_int_t ngx_ssl_engine_cpt_process_init(ngx_cycle_t *cycle);
+static void ngx_ssl_engine_cpt_process_exit(ngx_cycle_t *cycle);
+
+
+#define EXTERNAL_POLL_DEFAULT_INTERVAL              1
+#define HEURISTIC_POLL_DEFAULT_INTERVAL             0.5
+
+#define HEURISTIC_POLL_ASYM_DEFAULT_THRESHOLD       48
+#define HEURISTIC_POLL_SYM_DEFAULT_THRESHOLD        24
+#define HEURISTIC_POLL_MULTIBUFF_DEFAULT_THRESHOLD  8
+
+#define GET_NUM_ASYM_REQUESTS_IN_FLIGHT             1
+#define GET_NUM_KDF_REQUESTS_IN_FLIGHT              2
+#define GET_NUM_CIPHER_PIPELINE_REQUESTS_IN_FLIGHT  3
+#define GET_NUM_ASYM_NUM_ITEMS_IN_QUEUE             4
+#define GET_NUM_KDF_NUM_ITEMS_IN_QUEUE              5
+#define GET_NUM_SYM_NUM_ITEMS_IN_QUEUE              6
+
+#define INLINE_POLL     1
+#define INTERNAL_POLL   2
+#define EXTERNAL_POLL   3
+#define HEURISTIC_POLL  4
+
+#define HEARTBEAT_POLL_TIMEOUT  1000
+
+static ENGINE          *cpt_engine;
+
+static ngx_uint_t       cpt_engine_enable_inline_polling;
+
+static ngx_uint_t       cpt_engine_enable_internal_polling;
+
+static ngx_uint_t       cpt_engine_enable_heartbeat_polling = 0;
+
+
+static ngx_uint_t       cpt_engine_enable_external_polling;
+static ngx_int_t        cpt_engine_external_poll_interval;
+static ngx_event_t      cpt_engine_external_poll_event;
+static ngx_event_t      cpt_engine_heartbeat_poll_event;
+static ngx_connection_t dumb;
+
+static ngx_uint_t   cpt_engine_enable_heuristic_polling;
+static ngx_event_t  cpt_engine_heuristic_poll_event;
+static ngx_int_t    cpt_engine_heuristic_poll_asym_threshold;
+static ngx_int_t    cpt_engine_heuristic_poll_sym_threshold;
+static ngx_int_t    cpt_engine_heuristic_poll_asym_multibuff_threshold;
+static ngx_int_t    cpt_engine_heuristic_poll_sym_multibuff_threshold;
+
+/* Since any polling mode change need to restart Nginx service
+ * The initial polling mode is record when Nginx master start
+ * for valid configuration check during Nginx worker reload
+ * 0:unset, 1:inline, 2:internal, 3:external, 4:heuristic
+ */
+static ngx_int_t    cpt_engine_init_polling_mode = 0;
+
+typedef struct cpt_instance_status_s {
+    ngx_flag_t busy;
+    ngx_flag_t finished;
+    ngx_int_t  checkpoint;
+} cpt_instance_status_t;
+
+static cpt_instance_status_t cpt_instance_status;
+
+static int  num_heuristic_poll = 0;
+static int *num_asym_requests_in_flight = NULL;
+static int *num_kdf_requests_in_flight = NULL;
+static int *num_cipher_requests_in_flight = NULL;
+static int *num_asym_mb_items_in_queue = NULL;
+static int *num_kdf_mb_items_in_queue = NULL;
+static int *num_sym_mb_items_in_queue = NULL;
+
+static ngx_str_t ngx_ssl_engine_cpt_module_name = ngx_string("dpdk_engine");
+
+static ngx_command_t  ngx_ssl_engine_cpt_commands[] = {
+
+    { ngx_string("cpt_engine"),
+      NGX_SSL_ENGINE_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,
+      ngx_ssl_engine_cpt_block,
+      0,
+      0,
+      NULL },
+
+    { ngx_string("cpt_shutting_down_release"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_ssl_engine_cpt_releasable,
+      0,
+      offsetof(ngx_ssl_engine_cpt_conf_t, releasable),
+      NULL },
+
+    { ngx_string("cpt_sw_fallback"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_flag_slot,
+      0,
+      offsetof(ngx_ssl_engine_cpt_conf_t, enable_sw_fallback),
+      NULL },
+
+    { ngx_string("cpt_offload_mode"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      0,
+      offsetof(ngx_ssl_engine_cpt_conf_t, offload_mode),
+      NULL },
+
+    { ngx_string("cpt_notify_mode"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      0,
+      offsetof(ngx_ssl_engine_cpt_conf_t, notify_mode),
+      NULL },
+
+    { ngx_string("cpt_poll_mode"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      0,
+      offsetof(ngx_ssl_engine_cpt_conf_t, poll_mode),
+      NULL },
+
+    { ngx_string("cpt_internal_poll_interval"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      0,
+      offsetof(ngx_ssl_engine_cpt_conf_t, internal_poll_interval),
+      NULL },
+
+    { ngx_string("cpt_external_poll_interval"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      0,
+      offsetof(ngx_ssl_engine_cpt_conf_t, external_poll_interval),
+      NULL },
+
+    { ngx_string("cpt_heuristic_poll_asym_threshold"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      0,
+      offsetof(ngx_ssl_engine_cpt_conf_t, heuristic_poll_asym_threshold),
+      NULL },
+
+    { ngx_string("cpt_heuristic_poll_sym_threshold"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      0,
+      offsetof(ngx_ssl_engine_cpt_conf_t, heuristic_poll_sym_threshold),
+      NULL },
+
+    { ngx_string("cpt_heuristic_poll_asym_multibuff_threshold"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      0,
+      offsetof(ngx_ssl_engine_cpt_conf_t, heuristic_poll_asym_multibuff_threshold),
+      NULL },
+
+    { ngx_string("cpt_heuristic_poll_sym_multibuff_threshold"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      0,
+      offsetof(ngx_ssl_engine_cpt_conf_t, heuristic_poll_sym_multibuff_threshold),
+      NULL },
+
+    { ngx_string("cpt_small_pkt_offload_threshold"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_1MORE,
+      ngx_ssl_engine_cpt_set_threshold,
+      0,
+      offsetof(ngx_ssl_engine_cpt_conf_t, small_pkt_offload_threshold),
+      NULL },
+
+      ngx_null_command
+};
+
+ngx_ssl_engine_module_t  ngx_ssl_engine_cpt_module_ctx = {
+    &ngx_ssl_engine_cpt_module_name,
+    ngx_ssl_engine_cpt_create_conf,               /* create configuration */
+    ngx_ssl_engine_cpt_init_conf,                 /* init configuration */
+
+    {
+        ngx_ssl_engine_cpt_init,
+        ngx_ssl_engine_cpt_send_ctrl,
+        ngx_ssl_engine_cpt_register_handler,
+        ngx_ssl_engine_cpt_release,
+        ngx_ssl_engine_cpt_heuristic_poll
+    }
+};
+
+ngx_module_t  ngx_ssl_engine_cpt_module = {
+    NGX_MODULE_V1,
+    &ngx_ssl_engine_cpt_module_ctx,      /* module context */
+    ngx_ssl_engine_cpt_commands,         /* module directives */
+    NGX_SSL_ENGINE_MODULE,               /* module type */
+    NULL,                                /* init master */
+    NULL,                                /* init module */
+    ngx_ssl_engine_cpt_process_init,     /* init process */
+    NULL,                                /* init thread */
+    NULL,                                /* exit thread */
+    ngx_ssl_engine_cpt_process_exit,     /* exit process */
+    NULL,                                /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static ngx_int_t
+ngx_ssl_engine_cpt_init(ngx_cycle_t *cycle)
+{
+    ngx_memset(&cpt_instance_status, 0, sizeof(cpt_instance_status));
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_ssl_engine_cpt_release(ngx_cycle_t *cycle)
+{
+    unsigned int i;
+    ngx_connection_t  *c;
+
+    ngx_ssl_engine_cpt_conf_t *seqcf;
+
+    seqcf = ngx_engine_cycle_get_conf(cycle, ngx_ssl_engine_cpt_module);
+    if(seqcf == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                     "conf of engine_core_module is null");
+        return NGX_ERROR;
+    }
+
+    if(!seqcf->releasable || cpt_instance_status.finished) {
+
+        return NGX_OK;
+    }
+
+    c = cycle->connections;
+
+    i = cpt_instance_status.checkpoint;
+
+    for (; i < cycle->connection_n; i++) {
+        if (c[i].fd == -1) {
+            continue;
+        }
+
+        if ((c[i].ssl && !c[i].ssl->handshaked) ||
+            (!c[i].ssl && c[i].ssl_enabled)) {
+            ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0,
+                "connections in SSL handshake phase");
+            cpt_instance_status.checkpoint = i;
+            cpt_instance_status.busy = 1;
+            break;
+        }
+
+        cpt_instance_status.busy = 0;
+
+    }
+
+    if(!cpt_instance_status.busy) {
+        ENGINE *e = ENGINE_by_id((const char *) seqcf->engine_id.data);
+        ENGINE_GEN_INT_FUNC_PTR cpt_finish = ENGINE_get_finish_function(e);
+
+        if(0 == *num_asym_requests_in_flight &&
+           0 == *num_kdf_requests_in_flight &&
+           0 == *num_cipher_requests_in_flight &&
+           0 == *num_asym_mb_items_in_queue &&
+           0 == *num_kdf_mb_items_in_queue &&
+           0 == *num_sym_mb_items_in_queue &&
+           1 == cpt_finish(e)) {
+            cpt_instance_status.finished = 1;
+            ngx_log_debug0(NGX_LOG_DEBUG_CORE, cycle->log, 0,
+                                 "cpt engine finished");
+        } else {
+            ngx_log_debug0(NGX_LOG_DEBUG_CORE, cycle->log, 0,
+                                 "cpt engine finished error");
+        }
+
+        ENGINE_free(e);
+    }
+
+    return NGX_OK;
+}
+
+static ngx_int_t
+ngx_ssl_engine_cpt_send_ctrl(ngx_cycle_t *cycle)
+{
+    ngx_ssl_engine_cpt_conf_t *seqcf;
+    ngx_ssl_engine_conf_t *secf;
+
+    ENGINE     *e;
+    ngx_str_t  *value;
+    ngx_uint_t  i;
+
+    seqcf = ngx_engine_cycle_get_conf(cycle, ngx_ssl_engine_cpt_module);
+    if(seqcf == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                     "conf of engine_core_module is null");
+        return NGX_ERROR;
+    }
+
+    e = ENGINE_by_id((const char *) seqcf->engine_id.data);
+    if (e == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "ENGINE_by_id(\"%s\") failed",  seqcf->engine_id.data);
+        return NGX_ERROR;
+    }
+
+
+    if (ngx_strcmp(seqcf->offload_mode.data, "async") == 0) {
+        /* Need to be consistent with the directive ssl_async */
+    }
+
+    if (ngx_strcmp(seqcf->notify_mode.data, "event") == 0) {
+        if (!ENGINE_ctrl_cmd(e, "ENABLE_EVENT_DRIVEN_POLLING_MODE", 0, NULL,
+            NULL, 0)) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                            "cpt Engine failed: "
+                            "ENABLE_EVENT_DRIVEN_POLLING_MODE");
+            ENGINE_free(e);
+            return NGX_ERROR;
+        }
+    }
+
+
+    /* check the validity of possible polling mode switch for nginx reload */
+
+    if (cpt_engine_enable_internal_polling
+        && cpt_engine_init_polling_mode == INLINE_POLL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "Switch from inline to internal polling is invalid, "
+                      "and still use inline polling");
+
+        cpt_engine_enable_internal_polling = 0;
+        cpt_engine_enable_inline_polling = 1;
+    }
+
+    if (cpt_engine_enable_internal_polling
+        && cpt_engine_init_polling_mode == EXTERNAL_POLL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "Switch from external to internal polling is invalid, "
+                      "and still use external polling");
+
+        cpt_engine_enable_internal_polling = 0;
+        cpt_engine_enable_external_polling = 1;
+        cpt_engine_external_poll_interval = EXTERNAL_POLL_DEFAULT_INTERVAL;
+    }
+
+    if (cpt_engine_enable_internal_polling
+        && cpt_engine_init_polling_mode == HEURISTIC_POLL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "Switch from heuristic to internal polling is invalid, "
+                      "and still use heuristic polling");
+
+        cpt_engine_enable_internal_polling = 0;
+        cpt_engine_enable_heuristic_polling = 1;
+    }
+
+    /* check the offloaded algorithms in the inline polling mode */
+
+    secf = ngx_engine_cycle_get_conf(cycle, ngx_ssl_engine_core_module);
+    if(secf == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                     "conf of engine_core_module is null");
+        return NGX_ERROR;
+    }
+
+
+    if (cpt_engine_enable_inline_polling) {
+        if (secf->default_algorithms != NGX_CONF_UNSET_PTR) {
+            value = secf->default_algorithms->elts;
+            for (i = 0; i < secf->default_algorithms->nelts; i++) {
+                if (ngx_strcmp(value[i].data, "RSA") != 0) {
+                    ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                                  "Only RSA can be offloaded to cpt "
+                                  "in the inline polling mode");
+                    return NGX_ERROR;
+                }
+            }
+        } else {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "Only RSA can be offloaded to cpt "
+                          "in the inline polling mode");
+            return NGX_ERROR;
+        }
+    }
+
+    if (cpt_engine_enable_inline_polling) {
+        if (!ENGINE_ctrl_cmd(e, "ENABLE_INLINE_POLLING", 0, NULL, NULL, 0)) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "cpt Engine failed: ENABLE_INLINE_POLLING");
+            ENGINE_free(e);
+            return NGX_ERROR;
+        }
+    }
+
+    if (seqcf->enable_sw_fallback
+        && seqcf->enable_sw_fallback != NGX_CONF_UNSET) {
+        if (!ENGINE_ctrl_cmd(e, "ENABLE_SW_FALLBACK", 0, NULL, NULL, 0)) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "cpt Engine failed: ENABLE_SW_FALLBACK");
+            ENGINE_free(e);
+            return NGX_ERROR;
+        }
+    }
+
+    if (cpt_engine_enable_internal_polling
+        && seqcf->internal_poll_interval != NGX_CONF_UNSET) {
+        if (!ENGINE_ctrl_cmd(e, "SET_INTERNAL_POLL_INTERVAL",
+            (long) seqcf->internal_poll_interval, NULL, NULL, 0)) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "cpt Engine failed: SET_INTERNAL_POLL_INTERVAL");
+            ENGINE_free(e);
+            return NGX_ERROR;
+        }
+    }
+
+#if 0
+    if (cpt_engine_enable_external_polling || cpt_engine_enable_heuristic_polling) {
+        if (!ENGINE_ctrl_cmd(e, "ENABLE_EXTERNAL_POLLING", 0, NULL, NULL, 0)) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "cpt Engine failed: ENABLE_EXTERNAL_POLLING");
+            ENGINE_free(e);
+            return NGX_ERROR;
+        }
+    }
+
+    if (cpt_engine_enable_external_polling || cpt_engine_enable_heuristic_polling) {
+        if (!ENGINE_ctrl_cmd(e, "ENABLE_HEURISTIC_POLLING", 0, NULL, NULL, 0)) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "cpt Engine failed: ENABLE_HEURISTIC_POLLING");
+            ENGINE_free(e);
+            return NGX_ERROR;
+        }
+    }
+#endif
+
+    if (cpt_engine_enable_external_polling || cpt_engine_enable_heuristic_polling) {
+        if(seqcf->enable_sw_fallback
+            && seqcf->enable_sw_fallback != NGX_CONF_UNSET) {
+            cpt_engine_enable_heartbeat_polling = 1;
+        }
+    }
+
+    if (seqcf->small_pkt_offload_threshold != NGX_CONF_UNSET_PTR) {
+        value = seqcf->small_pkt_offload_threshold->elts;
+        for (i = 0; i < seqcf->small_pkt_offload_threshold->nelts; i++) {
+            if (!ENGINE_ctrl_cmd(e, "SET_CRYPTO_SMALL_PACKET_OFFLOAD_THRESHOLD",
+                0, value[i].data, NULL, 0)) {
+                ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                              "cpt Engine failed: "
+                              "SET_CRYPTO_SMALL_PACKET_OFFLOAD_THRESHOLD");
+                ENGINE_free(e);
+                return NGX_ERROR;
+            }
+        }
+    }
+
+    /* ssl engine global variable set */
+    if (cpt_engine_enable_heuristic_polling) {
+        ngx_ssl_engine_enable_heuristic_polling = 1;
+    }
+
+    /* record old polling mode to prevent invalid mode switch */
+
+    if (cpt_engine_enable_inline_polling) {
+        cpt_engine_init_polling_mode = INLINE_POLL;
+
+    } else if (cpt_engine_enable_internal_polling) {
+        cpt_engine_init_polling_mode = INTERNAL_POLL;
+
+    } else if (cpt_engine_enable_external_polling) {
+        cpt_engine_init_polling_mode = EXTERNAL_POLL;
+
+    } else if (cpt_engine_enable_heuristic_polling) {
+        cpt_engine_init_polling_mode = HEURISTIC_POLL;
+    }
+
+    ENGINE_free(e);
+
+    return NGX_OK;
+}
+
+static inline void
+cpt_engine_heartbeat_poll(ngx_log_t *log) {
+    int poll_status = 0;
+
+    if(cpt_instance_status.finished) {
+        return;
+    }
+
+    if (!ENGINE_ctrl_cmd(cpt_engine, "HEARTBEAT_POLL",  0, &poll_status, NULL, 0)) {
+        ngx_log_error(NGX_LOG_ALERT, log, 0, "cpt Engine failed: HEARTBEAT_POLL");
+    }
+}
+
+static void
+cpt_engine_heartbeat_poll_handler(ngx_event_t *ev)
+{
+    cpt_engine_heartbeat_poll(ev->log);
+
+    if (ngx_event_timer_rbtree.root != ngx_event_timer_rbtree.sentinel ||
+        !ngx_exiting) {
+        ngx_add_timer(ev, HEARTBEAT_POLL_TIMEOUT);
+    }
+}
+
+static inline void
+cpt_engine_poll(ngx_log_t *log) {
+    int poll_status = 0;
+
+    if (!ENGINE_ctrl_cmd(cpt_engine, "POLL", 0, &poll_status, NULL, 0)) {
+        ngx_log_error(NGX_LOG_ALERT, log, 0, "cpt Engine failed: POLL");
+    }
+}
+
+
+static void
+cpt_engine_external_poll_handler(ngx_event_t *ev)
+{
+    if(cpt_instance_status.finished) {
+        return;
+    }
+
+    if (*num_asym_requests_in_flight + *num_kdf_requests_in_flight
+           + *num_cipher_requests_in_flight + *num_asym_mb_items_in_queue
+           + *num_kdf_mb_items_in_queue + *num_sym_mb_items_in_queue > 0) {
+        cpt_engine_poll(ev->log);
+    }
+
+    if (ngx_event_timer_rbtree.root != ngx_event_timer_rbtree.sentinel ||
+        !ngx_exiting) {
+        ngx_add_timer(ev, cpt_engine_external_poll_interval);
+    }
+}
+
+
+static void
+cpt_engine_external_poll_init(ngx_log_t* log)
+{
+    memset(&cpt_engine_external_poll_event, 0, sizeof(ngx_event_t));
+
+    dumb.fd = (ngx_socket_t) -1;
+    cpt_engine_external_poll_event.data = &dumb;
+
+    cpt_engine_external_poll_event.handler = cpt_engine_external_poll_handler;
+    cpt_engine_external_poll_event.log = log;
+    cpt_engine_external_poll_event.cancelable = 0;
+
+    ngx_add_timer(&cpt_engine_external_poll_event, 100);
+    cpt_engine_external_poll_event.timer_set = 1;
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, log, 0, "Adding initial polling timer");
+}
+
+static void
+cpt_engine_heuristic_poll_handler(ngx_event_t *ev)
+{
+    if(cpt_instance_status.finished) {
+        return;
+    }
+
+    if (*num_asym_requests_in_flight + *num_kdf_requests_in_flight
+           + *num_cipher_requests_in_flight + *num_asym_mb_items_in_queue
+           + *num_kdf_mb_items_in_queue + *num_sym_mb_items_in_queue > 0) {
+        if (num_heuristic_poll == 0) {
+            cpt_engine_poll(ev->log);
+        }
+    }
+
+    if (*num_asym_requests_in_flight + *num_kdf_requests_in_flight
+           + *num_cipher_requests_in_flight + *num_asym_mb_items_in_queue
+           + *num_kdf_mb_items_in_queue + *num_sym_mb_items_in_queue > 0) {
+        if (ngx_event_timer_rbtree.root != ngx_event_timer_rbtree.sentinel ||
+            !ngx_exiting) {
+            num_heuristic_poll = 0;
+            ngx_add_timer(ev, HEURISTIC_POLL_DEFAULT_INTERVAL);
+        }
+    }
+}
+
+static void
+cpt_engine_heuristic_poll_init(ngx_log_t* log)
+{
+    memset(&cpt_engine_heuristic_poll_event, 0, sizeof(ngx_event_t));
+
+    dumb.fd = (ngx_socket_t) -1;
+    cpt_engine_heuristic_poll_event.data = &dumb;
+
+    cpt_engine_heuristic_poll_event.handler = cpt_engine_heuristic_poll_handler;
+    cpt_engine_heuristic_poll_event.log = log;
+    cpt_engine_heuristic_poll_event.cancelable = 0;
+}
+
+static void
+cpt_engine_heartbeat_poll_init(ngx_log_t* log)
+{
+    memset(&cpt_engine_heartbeat_poll_event, 0, sizeof(ngx_event_t));
+    dumb.fd = (ngx_socket_t) -1;
+    cpt_engine_heartbeat_poll_event.data = &dumb;
+    cpt_engine_heartbeat_poll_event.handler = cpt_engine_heartbeat_poll_handler;
+    cpt_engine_heartbeat_poll_event.log = log;
+    cpt_engine_heartbeat_poll_event.cancelable = 0;
+    ngx_add_timer(&cpt_engine_heartbeat_poll_event, HEARTBEAT_POLL_TIMEOUT);
+    cpt_engine_heartbeat_poll_event.timer_set = 1;
+}
+
+
+static ngx_int_t
+ngx_ssl_engine_cpt_register_handler(ngx_cycle_t *cycle)
+{
+    if (cpt_engine_enable_external_polling) {
+        cpt_engine_external_poll_init(cycle->log);
+    }
+
+    if (cpt_engine_enable_heuristic_polling) {
+        cpt_engine_heuristic_poll_init(cycle->log);
+    }
+
+    if (cpt_engine_enable_heartbeat_polling) {
+        cpt_engine_heartbeat_poll_init(cycle->log);
+    }
+
+    return NGX_OK;
+}
+
+
+static void
+ngx_ssl_engine_cpt_heuristic_poll(ngx_log_t *log) {
+    int polled_flag = 0;
+    int threshold;
+
+    if (*num_asym_requests_in_flight + *num_kdf_requests_in_flight
+        + *num_cipher_requests_in_flight +  *num_asym_mb_items_in_queue
+        + *num_kdf_mb_items_in_queue + *num_sym_mb_items_in_queue <= 0)
+        return;
+
+    /* one-time try to retrieve cpt responses */
+    if (*num_asym_requests_in_flight + *num_kdf_requests_in_flight
+        + *num_cipher_requests_in_flight +  *num_asym_mb_items_in_queue
+        + *num_kdf_mb_items_in_queue + *num_sym_mb_items_in_queue
+        >= (int) *ngx_ssl_active) {
+        cpt_engine_poll(log);
+        num_heuristic_poll ++;
+        polled_flag = 1;
+    }
+
+    if (!polled_flag) {
+        if (*num_asym_requests_in_flight > 0)
+            threshold = cpt_engine_heuristic_poll_asym_threshold;
+        else if (*num_asym_mb_items_in_queue > 0)
+            threshold = cpt_engine_heuristic_poll_asym_multibuff_threshold;
+        else if (*num_sym_mb_items_in_queue > 0)
+            threshold = cpt_engine_heuristic_poll_sym_multibuff_threshold;
+        else
+            threshold = cpt_engine_heuristic_poll_sym_threshold;
+
+        if (*num_asym_requests_in_flight + *num_kdf_requests_in_flight
+            + *num_cipher_requests_in_flight + *num_asym_mb_items_in_queue
+            + *num_kdf_mb_items_in_queue + *num_sym_mb_items_in_queue
+            >= threshold) {
+            cpt_engine_poll(log);
+            num_heuristic_poll ++;
+        }
+    }
+
+    if (*num_asym_requests_in_flight + *num_kdf_requests_in_flight
+        + *num_cipher_requests_in_flight+ *num_asym_mb_items_in_queue
+        + *num_kdf_mb_items_in_queue + *num_sym_mb_items_in_queue > 0
+        && !cpt_engine_heuristic_poll_event.timer_set) {
+        num_heuristic_poll = 0;
+        ngx_add_timer(&cpt_engine_heuristic_poll_event,
+                      HEURISTIC_POLL_DEFAULT_INTERVAL);
+    }
+}
+
+
+static char *
+ngx_ssl_engine_cpt_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char           *rv;
+    ngx_conf_t      pcf;
+
+    pcf = *cf;
+    cf->cmd_type = NGX_SSL_ENGINE_SUB_CONF;
+
+    rv = ngx_conf_parse(cf, NULL);
+
+    *cf = pcf;
+
+    if (rv != NGX_CONF_OK) {
+        return rv;
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_ssl_engine_cpt_set_threshold(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char *p = conf;
+
+    ngx_str_t          *value, *s;
+    ngx_array_t       **a;
+    ngx_uint_t          i;
+
+    a = (ngx_array_t **) (p + cmd->offset);
+
+    if (*a == NGX_CONF_UNSET_PTR) {
+        *a = ngx_array_create(cf->pool, cf->args->nelts - 1, sizeof(ngx_str_t));
+        if (*a == NULL) {
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    value = cf->args->elts;
+
+    for (i = 1; i < cf->args->nelts; i++) {
+        s = ngx_array_push(*a);
+        if (s == NULL) {
+            return NGX_CONF_ERROR;
+        }
+        *s = value[i];
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static void *
+ngx_ssl_engine_cpt_create_conf(ngx_cycle_t *cycle)
+{
+    ngx_ssl_engine_cpt_conf_t  *seqcf;
+
+    seqcf = ngx_pcalloc(cycle->pool, sizeof(ngx_ssl_engine_cpt_conf_t));
+    if (seqcf == NULL) {
+        return NULL;
+    }
+
+    /*
+     * set by ngx_pcalloc():
+     *
+     *     seqcf->offload_mode = NULL
+     *     seqcf->notify_mode = NULL
+     *     seqcf->poll_mode = NULL
+     */
+
+    cpt_engine_enable_inline_polling = 0;
+    cpt_engine_enable_internal_polling = 0;
+    cpt_engine_enable_external_polling = 0;
+    cpt_engine_enable_heuristic_polling = 0;
+
+    seqcf->releasable = NGX_CONF_UNSET;
+    seqcf->enable_sw_fallback = NGX_CONF_UNSET;
+    seqcf->external_poll_interval = NGX_CONF_UNSET;
+    seqcf->internal_poll_interval = NGX_CONF_UNSET;
+
+    seqcf->heuristic_poll_asym_threshold = NGX_CONF_UNSET;
+    seqcf->heuristic_poll_sym_threshold = NGX_CONF_UNSET;
+    seqcf->heuristic_poll_asym_multibuff_threshold = NGX_CONF_UNSET;
+    seqcf->heuristic_poll_sym_multibuff_threshold = NGX_CONF_UNSET;
+
+    seqcf->small_pkt_offload_threshold = NGX_CONF_UNSET_PTR;
+
+    return seqcf;
+}
+
+
+static char *
+ngx_ssl_engine_cpt_releasable(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_str_t  *value;
+    ngx_uint_t  i;
+    char  *rv;
+    ngx_ssl_engine_conf_t *secf;
+    ngx_ssl_engine_cpt_conf_t *seqcf = conf;
+
+    secf = ngx_engine_cycle_get_conf(cf->cycle, ngx_ssl_engine_core_module);
+    if(secf == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cf->cycle->log, 0,
+                     "conf of engine_core_module is null");
+        return NGX_CONF_ERROR;
+    }
+
+
+    if (seqcf->poll_mode.data == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cf->cycle->log, 0,
+                      "Please specify polling mode before"
+                      "cpt_shutting_down_release is set");
+        return NGX_CONF_ERROR;
+    }
+
+
+    rv = ngx_conf_set_flag_slot(cf, cmd, conf);
+
+    if (rv != NGX_CONF_OK) {
+        return rv;
+    }
+
+    if (seqcf->releasable) {
+        /* Currently cpt release while worker shutting down feature
+         * is unavailable when CIPHERS is offloaded to cpt.
+         * Logic in below block will prevent the release if CIPHERS
+         * is offloaded to cpt.
+         */
+        if (secf->default_algorithms == NGX_CONF_UNSET_PTR) {
+            ngx_log_error(NGX_LOG_EMERG, cf->cycle->log, 0,
+                          "cpt is unreleasable during worker shutting down due "
+                          "to CIPHERS is offloaded");
+            seqcf->releasable = 0;
+
+        } else {
+            value = secf->default_algorithms->elts;
+            for (i = 0; i < secf->default_algorithms->nelts; i++) {
+                if (ngx_strstr(value[i].data, "ALL") != NULL ||
+                    ngx_strstr(value[i].data, "CIPHERS") != NULL) {
+                    ngx_log_error(NGX_LOG_EMERG, cf->cycle->log, 0,
+                                  "cpt is unreleasable during worker shutting "
+                                  "down due to CIPHERS is offloaded");
+                    seqcf->releasable = 0;
+                }
+            }
+        }
+
+        if (ngx_strcmp(seqcf->poll_mode.data, "external") != 0 &&
+            ngx_strcmp(seqcf->poll_mode.data, "heuristic") != 0) {
+            ngx_log_error(NGX_LOG_EMERG, cf->cycle->log, 0,
+                          "cpt is releasable only external or heuristic polling "
+                          "mode is set");
+            seqcf->releasable = 0;
+        }
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_ssl_engine_cpt_init_conf(ngx_cycle_t *cycle, void *conf)
+{
+    ngx_ssl_engine_cpt_conf_t *seqcf = conf;
+    ngx_ssl_engine_conf_t * corecf =
+        ngx_engine_cycle_get_conf(cycle, ngx_ssl_engine_core_module);
+    if(corecf == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                     "conf of engine_core_module is null");
+        return NGX_CONF_ERROR;
+    }
+
+
+    if (0 != corecf->ssl_engine_id.len) {
+        ngx_conf_init_str_value(seqcf->engine_id, corecf->ssl_engine_id.data);
+    } else {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0, "No engine id found.");
+        return NGX_CONF_ERROR;
+    }
+
+    ngx_conf_init_str_value(seqcf->offload_mode, "async");
+    ngx_conf_init_str_value(seqcf->notify_mode, "poll");
+    ngx_conf_init_str_value(seqcf->poll_mode, "internal");
+
+    ngx_conf_init_value(seqcf->releasable, 0);
+
+    ngx_conf_init_value(seqcf->heuristic_poll_asym_threshold,
+                        HEURISTIC_POLL_ASYM_DEFAULT_THRESHOLD);
+
+    ngx_conf_init_value(seqcf->heuristic_poll_sym_threshold,
+                        HEURISTIC_POLL_SYM_DEFAULT_THRESHOLD);
+
+    ngx_conf_init_value(seqcf->heuristic_poll_asym_multibuff_threshold,
+                        HEURISTIC_POLL_MULTIBUFF_DEFAULT_THRESHOLD);
+
+    ngx_conf_init_value(seqcf->heuristic_poll_sym_multibuff_threshold,
+                        HEURISTIC_POLL_MULTIBUFF_DEFAULT_THRESHOLD);
+
+    /* check the validity of the conf values */
+
+    if (ngx_strcmp(seqcf->offload_mode.data, "sync") != 0
+        && ngx_strcmp(seqcf->offload_mode.data, "async") != 0) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "wrong type for cpt_offload_mode");
+        return NGX_CONF_ERROR;
+    }
+
+    if (ngx_strcmp(seqcf->notify_mode.data, "event") != 0
+        && ngx_strcmp(seqcf->notify_mode.data, "poll") != 0) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "wrong type for cpt_notify_mode");
+        return NGX_CONF_ERROR;
+    }
+
+    if (ngx_strcmp(seqcf->poll_mode.data, "inline") != 0
+        && ngx_strcmp(seqcf->poll_mode.data, "internal") != 0
+        && ngx_strcmp(seqcf->poll_mode.data, "external") != 0
+        && ngx_strcmp(seqcf->poll_mode.data, "heuristic") != 0) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "wrong type for cpt_poll_mode");
+        return NGX_CONF_ERROR;
+    }
+
+    /* check the validity of the engine ctrl combination */
+
+    if (ngx_strcmp(seqcf->offload_mode.data, "sync") == 0) {
+        if (ngx_strcmp(seqcf->notify_mode.data, "event") == 0
+            && ngx_strcmp(seqcf->poll_mode.data, "inline") == 0) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "\"sync + event + inline\" is invalid");
+            return NGX_CONF_ERROR;
+        }
+
+        if (ngx_strcmp(seqcf->poll_mode.data, "external") == 0
+            || ngx_strcmp(seqcf->poll_mode.data, "heuristic") == 0) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "\"sync + external/heuristic\" is invalid");
+            return NGX_CONF_ERROR;
+        }
+    } else {
+        /* async mode */
+
+        if (ngx_strcmp(seqcf->poll_mode.data, "inline") == 0) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "\"async + inline\" is invalid");
+            return NGX_CONF_ERROR;
+        }
+
+        if (ngx_strcmp(seqcf->notify_mode.data, "event") == 0
+            && ngx_strcmp(seqcf->poll_mode.data, "external") == 0) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "\"async + event + external\" "
+                          "is currently not supported");
+            return NGX_CONF_ERROR;
+        }
+
+        if (ngx_strcmp(seqcf->notify_mode.data, "event") == 0
+            && ngx_strcmp(seqcf->poll_mode.data, "heuristic") == 0) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "\"async + event + heuristic\" is invalid");
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    if (seqcf->external_poll_interval > 1000
+        || seqcf->external_poll_interval == 0) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "invalid external poll interval");
+        return NGX_CONF_ERROR;
+    }
+
+    if (seqcf->internal_poll_interval > 10000000
+        || seqcf->internal_poll_interval == 0) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "invalid internal poll interval");
+        return NGX_CONF_ERROR;
+    }
+
+    if (seqcf->heuristic_poll_asym_threshold > 512
+        || seqcf->heuristic_poll_sym_threshold > 512
+        || seqcf->heuristic_poll_asym_multibuff_threshold > 512
+        || seqcf->heuristic_poll_sym_multibuff_threshold > 512 ) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "invalid heuristic poll threshold");
+        return NGX_CONF_ERROR;
+    }
+
+    /* global variable set */
+
+    if (ngx_strcmp(seqcf->notify_mode.data, "poll") == 0
+        && ngx_strcmp(seqcf->poll_mode.data, "inline") == 0) {
+        cpt_engine_enable_inline_polling = 1;
+    }
+
+    if (ngx_strcmp(seqcf->notify_mode.data, "poll") == 0
+        && ngx_strcmp(seqcf->poll_mode.data, "internal") == 0) {
+        cpt_engine_enable_internal_polling = 1;
+    }
+
+    if (ngx_strcmp(seqcf->notify_mode.data, "poll") == 0
+        && ngx_strcmp(seqcf->poll_mode.data, "external") == 0) {
+        cpt_engine_enable_external_polling = 1;
+        ngx_conf_init_value(seqcf->external_poll_interval,
+                            EXTERNAL_POLL_DEFAULT_INTERVAL);
+    }
+
+    if (ngx_strcmp(seqcf->notify_mode.data, "poll") == 0
+        && ngx_strcmp(seqcf->poll_mode.data, "heuristic") == 0) {
+        cpt_engine_enable_heuristic_polling = 1;
+    }
+
+    cpt_engine_external_poll_interval = seqcf->external_poll_interval;
+
+    cpt_engine_heuristic_poll_asym_threshold
+        = seqcf->heuristic_poll_asym_threshold;
+
+    cpt_engine_heuristic_poll_sym_threshold
+        = seqcf->heuristic_poll_sym_threshold;
+
+    cpt_engine_heuristic_poll_asym_multibuff_threshold
+        = seqcf->heuristic_poll_asym_multibuff_threshold;
+
+    cpt_engine_heuristic_poll_sym_multibuff_threshold
+        = seqcf->heuristic_poll_sym_multibuff_threshold;
+
+    return NGX_CONF_OK;
+}
+
+
+static ngx_int_t
+cpt_engine_share_info(ngx_log_t *log) {
+    if (!ENGINE_ctrl_cmd(cpt_engine, "GET_NUM_REQUESTS_IN_FLIGHT",
+        GET_NUM_ASYM_REQUESTS_IN_FLIGHT,
+        &num_asym_requests_in_flight, NULL, 0)) {
+        ngx_log_error(NGX_LOG_EMERG, log, 0,
+                      "cpt Engine failed: GET_NUM_REQUESTS_IN_FLIGHT");
+        return NGX_ERROR;
+    }
+
+    if (!ENGINE_ctrl_cmd(cpt_engine, "GET_NUM_REQUESTS_IN_FLIGHT",
+        GET_NUM_KDF_REQUESTS_IN_FLIGHT,
+        &num_kdf_requests_in_flight, NULL, 0)) {
+        ngx_log_error(NGX_LOG_EMERG, log, 0,
+                      "cpt Engine failed: GET_NUM_REQUESTS_IN_FLIGHT");
+        return NGX_ERROR;
+    }
+
+    if (!ENGINE_ctrl_cmd(cpt_engine, "GET_NUM_REQUESTS_IN_FLIGHT",
+        GET_NUM_CIPHER_PIPELINE_REQUESTS_IN_FLIGHT,
+        &num_cipher_requests_in_flight, NULL, 0)) {
+        ngx_log_error(NGX_LOG_EMERG, log, 0,
+                      "cpt Engine failed: GET_NUM_REQUESTS_IN_FLIGHT");
+        return NGX_ERROR;
+    }
+    if (!ENGINE_ctrl_cmd(cpt_engine, "GET_NUM_REQUESTS_IN_FLIGHT",
+        GET_NUM_ASYM_NUM_ITEMS_IN_QUEUE,
+        &num_asym_mb_items_in_queue, NULL, 0)) {
+        ngx_log_error(NGX_LOG_EMERG, log, 0,
+                      "cpt Engine failed: GET_NUM_REQUESTS_IN_FLIGHT");
+        return NGX_ERROR;
+    }
+    if (!ENGINE_ctrl_cmd(cpt_engine, "GET_NUM_REQUESTS_IN_FLIGHT",
+        GET_NUM_KDF_NUM_ITEMS_IN_QUEUE,
+        &num_kdf_mb_items_in_queue, NULL, 0)) {
+        ngx_log_error(NGX_LOG_EMERG, log, 0,
+                      "cpt Engine failed: GET_NUM_REQUESTS_IN_FLIGHT");
+        return NGX_ERROR;
+    }
+    if (!ENGINE_ctrl_cmd(cpt_engine, "GET_NUM_REQUESTS_IN_FLIGHT",
+        GET_NUM_SYM_NUM_ITEMS_IN_QUEUE,
+        &num_sym_mb_items_in_queue, NULL, 0)) {
+        ngx_log_error(NGX_LOG_EMERG, log, 0,
+                      "cpt Engine failed: GET_NUM_REQUESTS_IN_FLIGHT");
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_ssl_engine_cpt_process_init(ngx_cycle_t *cycle)
+{
+    num_heuristic_poll = 0;
+    num_asym_requests_in_flight = NULL;
+    num_kdf_requests_in_flight = NULL;
+    num_cipher_requests_in_flight = NULL;
+    num_asym_mb_items_in_queue = NULL;
+    num_kdf_mb_items_in_queue  = NULL;
+    num_sym_mb_items_in_queue = NULL;
+
+    if (NGX_PROCESS_MASTER == ngx_process) {
+        return NGX_OK;
+    }
+
+    if (ngx_ssl_engine_set(cycle) != NGX_OK) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0, "ssl engine set failed");
+        return NGX_ERROR;
+    }
+
+    ngx_ssl_engine_cpt_conf_t *conf =
+        ngx_engine_cycle_get_conf(cycle, ngx_ssl_engine_cpt_module);
+    if (conf == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                     "conf of engine_core_module is null");
+        return NGX_ERROR;
+    }
+
+    if (0 == (const char *) conf->engine_id.len) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                     "engine id not found");
+        return NGX_ERROR;
+    }
+
+    cpt_engine = ENGINE_by_id((const char *) conf->engine_id.data);
+    if (cpt_engine == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "ENGINE_by_id(\"%s\") failed", conf->engine_id.data);
+        return NGX_ERROR;
+    }
+
+    if (cpt_engine_share_info(cycle->log) != NGX_OK) {
+        ENGINE_free(cpt_engine);
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+static void
+ngx_ssl_engine_cpt_process_exit(ngx_cycle_t *cycle)
+{
+    if (NGX_PROCESS_MASTER == ngx_process) {
+        return;
+    }
+
+    ngx_ssl_engine_cpt_conf_t *conf =
+        ngx_engine_cycle_get_conf(cycle, ngx_ssl_engine_cpt_module);
+    if (conf == NULL) {
+        return;
+    }
+
+    if (cpt_engine) {
+        ENGINE_finish(cpt_engine);
+        ENGINE_free(cpt_engine);
+    }
+
+    cpt_engine = NULL;
+
+    ENGINE_cleanup();
+}
diff --git a/src/core/nginx.c b/src/core/nginx.c
index 48a20e9fd..449e95aae 100644
--- a/src/core/nginx.c
+++ b/src/core/nginx.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -182,6 +183,10 @@ ngx_module_t  ngx_core_module = {
 static ngx_uint_t   ngx_show_help;
 static ngx_uint_t   ngx_show_version;
 static ngx_uint_t   ngx_show_configure;
+/* indicate that nginx start without ngx_ssl_init()
+ * which will involve OpenSSL configuration file to
+ * start OpenSSL engine */
+ngx_uint_t          ngx_no_ssl_init;
 static u_char      *ngx_prefix;
 static u_char      *ngx_error_log;
 static u_char      *ngx_conf_file;
@@ -248,6 +253,7 @@ main(int argc, char *const *argv)

     ngx_memzero(&init_cycle, sizeof(ngx_cycle_t));
     init_cycle.log = log;
+    init_cycle.no_ssl_init = ngx_no_ssl_init;
     ngx_cycle = &init_cycle;

     init_cycle.pool = ngx_create_pool(1024, log);
@@ -782,11 +788,13 @@ ngx_get_options(int argc, char *const *argv)

             case 't':
                 ngx_test_config = 1;
+                ngx_no_ssl_init = 1;
                 break;

             case 'T':
                 ngx_test_config = 1;
                 ngx_dump_config = 1;
+                ngx_no_ssl_init = 1;
                 break;

             case 'q':
@@ -854,6 +862,7 @@ ngx_get_options(int argc, char *const *argv)
                 return NGX_ERROR;

             case 's':
+                ngx_no_ssl_init = 1;
                 if (*p) {
                     ngx_signal = (char *) p;

@@ -879,6 +888,7 @@ ngx_get_options(int argc, char *const *argv)

             default:
                 ngx_log_stderr(0, "invalid option: \"%c\"", *(p - 1));
+                ngx_no_ssl_init = 1;
                 return NGX_ERROR;
             }
         }
diff --git a/src/core/ngx_buf.h b/src/core/ngx_buf.h
index fdcd0cddf..66b6ce9ed 100644
--- a/src/core/ngx_buf.h
+++ b/src/core/ngx_buf.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -134,7 +135,7 @@ typedef struct {
      && !(b)->in_file && !(b)->flush && !(b)->last_buf)

 #define ngx_buf_size(b)                                                      \
-    (ngx_buf_in_memory(b) ? (off_t) ((b)->last - (b)->pos):                  \
+    (ngx_buf_in_memory(b) ? (off_t) (unsigned) ((b)->last - (b)->pos):       \
                             ((b)->file_last - (b)->file_pos))

 ngx_buf_t *ngx_create_temp_buf(ngx_pool_t *pool, size_t size);
diff --git a/src/core/ngx_conf_file.h b/src/core/ngx_conf_file.h
index ed2d2ba9d..fa971e416 100644
--- a/src/core/ngx_conf_file.h
+++ b/src/core/ngx_conf_file.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -129,6 +130,7 @@ struct ngx_conf_s {

     ngx_conf_handler_pt   handler;
     void                 *handler_conf;
+    ngx_flag_t            no_ssl_init;
 };


@@ -202,6 +204,12 @@ char *ngx_conf_check_num_bounds(ngx_conf_t *cf, void *post, void *data);
         conf = default;                                                      \
     }

+#define ngx_conf_init_str_value(conf, default)                               \
+    if (conf.data == NULL) {                                                 \
+        conf.len = sizeof(default) - 1;                                      \
+        conf.data = (u_char *) default;                                      \
+    }
+
 #define ngx_conf_merge_value(conf, prev, default)                            \
     if (conf == NGX_CONF_UNSET) {                                            \
         conf = (prev == NGX_CONF_UNSET) ? default : prev;                    \
diff --git a/src/core/ngx_connection.c b/src/core/ngx_connection.c
index fe729a78a..95288394a 100644
--- a/src/core/ngx_connection.c
+++ b/src/core/ngx_connection.c
@@ -2,12 +2,14 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


 #include <ngx_config.h>
 #include <ngx_core.h>
 #include <ngx_event.h>
+#include <ngx_ssl_engine.h>


 ngx_os_io_t  ngx_io;
@@ -1048,7 +1050,14 @@ ngx_close_listening_sockets(ngx_cycle_t *cycle)
                      * for closed shared listening sockets unless
                      * the events was explicitly deleted
                      */
-
+#if (NGX_SSL)
+                    if (c->asynch && ngx_del_async_conn) {
+                        if (c->num_async_fds) {
+                            ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                            c->num_async_fds--;
+                        }
+                    }
+#endif
                     ngx_del_event(c->read, NGX_READ_EVENT, 0);

                 } else {
@@ -1098,6 +1107,9 @@ ngx_get_connection(ngx_socket_t s, ngx_log_t *log)
 {
     ngx_uint_t         instance;
     ngx_event_t       *rev, *wev;
+#if (NGX_SSL)
+    ngx_event_t       *aev;
+#endif
     ngx_connection_t  *c;

     /* disable warning: Win32 SOCKET is u_int while UNIX socket is int */
@@ -1131,11 +1143,18 @@ ngx_get_connection(ngx_socket_t s, ngx_log_t *log)

     rev = c->read;
     wev = c->write;
+#if (NGX_SSL)
+    aev = c->async;
+#endif

     ngx_memzero(c, sizeof(ngx_connection_t));

     c->read = rev;
     c->write = wev;
+#if (NGX_SSL)
+    c->async = aev;
+#endif
+
     c->fd = s;
     c->log = log;

@@ -1143,17 +1162,32 @@ ngx_get_connection(ngx_socket_t s, ngx_log_t *log)

     ngx_memzero(rev, sizeof(ngx_event_t));
     ngx_memzero(wev, sizeof(ngx_event_t));
+#if (NGX_SSL)
+    ngx_memzero(aev, sizeof(ngx_event_t));
+#endif

     rev->instance = !instance;
     wev->instance = !instance;
+#if (NGX_SSL)
+    aev->instance = !instance;
+#endif

     rev->index = NGX_INVALID_INDEX;
     wev->index = NGX_INVALID_INDEX;
+#if (NGX_SSL)
+    aev->index = NGX_INVALID_INDEX;
+#endif

     rev->data = c;
     wev->data = c;
+#if (NGX_SSL)
+    aev->data = c;
+#endif

     wev->write = 1;
+#if (NGX_SSL)
+    aev->async = 1;
+#endif

     return c;
 }
@@ -1192,11 +1226,32 @@ ngx_close_connection(ngx_connection_t *c)
         ngx_del_timer(c->write);
     }

+#if (NGX_SSL)
+    if (c->async->timer_set) {
+        ngx_del_timer(c->async);
+    }
+
+    if (c->asynch && ngx_del_async_conn) {
+        if (c->num_async_fds) {
+            ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+            c->num_async_fds--;
+        }
+    }
+#endif
+
     if (!c->shared) {
         if (ngx_del_conn) {
             ngx_del_conn(c, NGX_CLOSE_EVENT);

         } else {
+#if (NGX_SSL)
+            if (c->asynch && ngx_del_async_conn) {
+                if (c->num_async_fds) {
+                    ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                    c->num_async_fds--;
+                }
+            }
+#endif
             if (c->read->active || c->read->disabled) {
                 ngx_del_event(c->read, NGX_READ_EVENT, NGX_CLOSE_EVENT);
             }
@@ -1215,8 +1270,17 @@ ngx_close_connection(ngx_connection_t *c)
         ngx_delete_posted_event(c->write);
     }

+#if (NGX_SSL)
+    if (c->async->posted) {
+        ngx_delete_posted_event(c->async);
+    }
+#endif
+
     c->read->closed = 1;
     c->write->closed = 1;
+#if (NGX_SSL)
+    c->async->closed = 1;
+#endif

     ngx_reusable_connection(c, 0);

@@ -1226,6 +1290,9 @@ ngx_close_connection(ngx_connection_t *c)

     fd = c->fd;
     c->fd = (ngx_socket_t) -1;
+#if (NGX_SSL)
+    c->async_fd = (ngx_socket_t) -1;
+#endif

     if (c->shared) {
         return;
@@ -1273,6 +1340,13 @@ ngx_reusable_connection(ngx_connection_t *c, ngx_uint_t reusable)
 #if (NGX_STAT_STUB)
         (void) ngx_atomic_fetch_add(ngx_stat_waiting, -1);
 #endif
+
+#if (NGX_SSL)
+        if (c->ssl_enabled && ngx_use_ssl_engine
+            && ngx_ssl_engine_enable_heuristic_polling) {
+            (void) ngx_atomic_fetch_add(ngx_ssl_active, 1);
+        }
+#endif
     }

     c->reusable = reusable;
@@ -1287,6 +1361,14 @@ ngx_reusable_connection(ngx_connection_t *c, ngx_uint_t reusable)
 #if (NGX_STAT_STUB)
         (void) ngx_atomic_fetch_add(ngx_stat_waiting, 1);
 #endif
+
+#if (NGX_SSL)
+        if (c->ssl_enabled && ngx_use_ssl_engine
+            && ngx_ssl_engine_enable_heuristic_polling) {
+            (void) ngx_atomic_fetch_add(ngx_ssl_active, -1);
+            ngx_ssl_engine_heuristic_poll(c->log);
+        }
+#endif
     }
 }

diff --git a/src/core/ngx_connection.h b/src/core/ngx_connection.h
index 8cc14755a..2c14e953d 100644
--- a/src/core/ngx_connection.h
+++ b/src/core/ngx_connection.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -123,9 +124,14 @@ struct ngx_connection_s {
     void               *data;
     ngx_event_t        *read;
     ngx_event_t        *write;
+#if (NGX_SSL)
+    ngx_event_t        *async;
+#endif

     ngx_socket_t        fd;
-
+#if (NGX_SSL)
+    ngx_socket_t        async_fd;
+#endif
     ngx_recv_pt         recv;
     ngx_send_pt         send;
     ngx_recv_chain_pt   recv_chain;
@@ -149,6 +155,8 @@ struct ngx_connection_s {

 #if (NGX_SSL || NGX_COMPAT)
     ngx_ssl_connection_t  *ssl;
+    ngx_flag_t          asynch;
+    unsigned            ssl_enabled:1;
 #endif

     ngx_udp_connection_t  *udp;
@@ -184,6 +192,9 @@ struct ngx_connection_s {
     unsigned            tcp_nopush:2;    /* ngx_connection_tcp_nopush_e */

     unsigned            need_last_buf:1;
+#if (NGX_SSL)
+    unsigned            num_async_fds:8;
+#endif

 #if (NGX_HAVE_SENDFILE_NODISKIO || NGX_COMPAT)
     unsigned            busy_count:2;
diff --git a/src/core/ngx_cycle.c b/src/core/ngx_cycle.c
index 6978c3e43..0a5da8e47 100644
--- a/src/core/ngx_cycle.c
+++ b/src/core/ngx_cycle.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -81,6 +82,7 @@ ngx_init_cycle(ngx_cycle_t *old_cycle)
     cycle->pool = pool;
     cycle->log = log;
     cycle->old_cycle = old_cycle;
+    cycle->no_ssl_init = old_cycle->no_ssl_init;

     cycle->conf_prefix.len = old_cycle->conf_prefix.len;
     cycle->conf_prefix.data = ngx_pstrdup(pool, &old_cycle->conf_prefix);
@@ -270,6 +272,7 @@ ngx_init_cycle(ngx_cycle_t *old_cycle)
     conf.log = log;
     conf.module_type = NGX_CORE_MODULE;
     conf.cmd_type = NGX_MAIN_CONF;
+    conf.no_ssl_init = cycle->no_ssl_init;

 #if 0
     log->log_level = NGX_LOG_DEBUG_ALL;
@@ -1049,6 +1052,7 @@ ngx_create_pidfile(ngx_str_t *name, ngx_log_t *log)
         len = ngx_snprintf(pid, NGX_INT64_LEN + 2, "%P%N", ngx_pid) - pid;

         if (ngx_write_file(&file, pid, len, 0) == NGX_ERROR) {
+            ngx_close_file(file.fd);
             rc = NGX_ERROR;
         }
     }
diff --git a/src/core/ngx_cycle.h b/src/core/ngx_cycle.h
index 0c47f25fe..1b61e8741 100644
--- a/src/core/ngx_cycle.h
+++ b/src/core/ngx_cycle.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -73,6 +74,9 @@ struct ngx_cycle_s {
     ngx_connection_t         *connections;
     ngx_event_t              *read_events;
     ngx_event_t              *write_events;
+#if (NGX_SSL)
+    ngx_event_t              *async_events;
+#endif

     ngx_cycle_t              *old_cycle;

@@ -83,6 +87,7 @@ struct ngx_cycle_s {
     ngx_str_t                 error_log;
     ngx_str_t                 lock_file;
     ngx_str_t                 hostname;
+    ngx_flag_t                no_ssl_init;
 };


diff --git a/src/core/ngx_resolver.c b/src/core/ngx_resolver.c
index 6d129e56a..08db59737 100644
--- a/src/core/ngx_resolver.c
+++ b/src/core/ngx_resolver.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -4461,6 +4462,9 @@ ngx_udp_connect(ngx_resolver_connection_t *rec)

     rev->log = &rec->log;
     wev->log = &rec->log;
+#if (NGX_SSL)
+    c->async->log = &rec->log;
+#endif

     rec->udp = c;

@@ -4549,6 +4553,9 @@ ngx_tcp_connect(ngx_resolver_connection_t *rec)

     rev->log = &rec->log;
     wev->log = &rec->log;
+#if (NGX_SSL)
+    c->async->log = &rec->log;
+#endif

     rec->tcp = c;

diff --git a/src/core/ngx_string.h b/src/core/ngx_string.h
index 0fb9be72e..8cd950f2f 100644
--- a/src/core/ngx_string.h
+++ b/src/core/ngx_string.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -98,6 +99,16 @@ void *ngx_memcpy(void *dst, const void *src, size_t n);

 #else

+#if (NGX_SECURE_MEM)
+
+#define _MIN_(a,b) (((a)<(b))?(a):(b))
+#define MEMCPY_S(dest, src, dest_sz, src_sz) \
+            memcpy((void *)(dest), (void *) (src), (size_t)_MIN_(dest_sz, src_sz))
+#define ngx_memcpy(dst, src, n)   (void) MEMCPY_S(dst, src, n, n)
+#define ngx_cpymem(dst, src, n)   (((u_char *) MEMCPY_S(dst, src, n, n)) + (n))
+
+#else
+
 /*
  * gcc3, msvc, and icc7 compile memcpy() to the inline "rep movs".
  * gcc3 compiles memcpy(d, s, 4) to the inline "mov"es.
@@ -106,8 +117,9 @@ void *ngx_memcpy(void *dst, const void *src, size_t n);
 #define ngx_memcpy(dst, src, n)   (void) memcpy(dst, src, n)
 #define ngx_cpymem(dst, src, n)   (((u_char *) memcpy(dst, src, n)) + (n))

-#endif
+#endif /* NGX_SECURE_MEM */

+#endif /* NGX_MEMCPY_LIMIT */

 #if ( __INTEL_COMPILER >= 800 )

diff --git a/src/engine/modules/ngx_ssl_engine_dasync_module.c b/src/engine/modules/ngx_ssl_engine_dasync_module.c
new file mode 100644
index 000000000..18a8f8715
--- /dev/null
+++ b/src/engine/modules/ngx_ssl_engine_dasync_module.c
@@ -0,0 +1,236 @@
+/* ====================================================================
+ *
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2016-2021 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ * ====================================================================
+ */
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_ssl_engine.h>
+
+/* dummy async engine provided by OpenSSL */
+
+
+typedef struct {
+    /* only async for dasync engine, typically sync or async */
+    ngx_str_t       offload_mode;
+
+    /* no need for dasync engine, typically event or poll */
+    ngx_str_t       notify_mode;
+
+    /* no need for dasync engine */
+    ngx_str_t       poll_mode;
+} ngx_ssl_engine_dasync_conf_t;
+
+
+static ngx_int_t ngx_ssl_engine_dasync_send_ctrl(ngx_cycle_t *cycle);
+static ngx_int_t ngx_ssl_engine_dasync_register_handler(ngx_cycle_t *cycle);
+
+static char *ngx_ssl_engine_dasync_block(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+
+static void *ngx_ssl_engine_dasync_create_conf(ngx_cycle_t *cycle);
+static char *ngx_ssl_engine_dasync_init_conf(ngx_cycle_t *cycle, void *conf);
+
+static void ngx_ssl_engine_dasync_process_exit(ngx_cycle_t *cycle);
+
+
+static ngx_str_t      ssl_engine_dasync_name = ngx_string("dasync");
+
+static ngx_command_t  ngx_ssl_engine_dasync_commands[] = {
+
+    { ngx_string("dasync_engine"),
+      NGX_SSL_ENGINE_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,
+      ngx_ssl_engine_dasync_block,
+      0,
+      0,
+      NULL },
+
+    { ngx_string("dasync_offload_mode"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      0,
+      offsetof(ngx_ssl_engine_dasync_conf_t, offload_mode),
+      NULL },
+
+    { ngx_string("dasync_notify_mode"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      0,
+      offsetof(ngx_ssl_engine_dasync_conf_t, notify_mode),
+      NULL },
+
+    { ngx_string("dasync_poll_mode"),
+      NGX_SSL_ENGINE_SUB_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      0,
+      offsetof(ngx_ssl_engine_dasync_conf_t, poll_mode),
+      NULL },
+
+      ngx_null_command
+};
+
+ngx_ssl_engine_module_t  ngx_ssl_engine_dasync_module_ctx = {
+    &ssl_engine_dasync_name,
+    ngx_ssl_engine_dasync_create_conf,               /* create configuration */
+    ngx_ssl_engine_dasync_init_conf,                 /* init configuration */
+
+    {
+        NULL,
+        ngx_ssl_engine_dasync_send_ctrl,
+        ngx_ssl_engine_dasync_register_handler,
+        NULL,
+        NULL
+    }
+};
+
+ngx_module_t  ngx_ssl_engine_dasync_module = {
+    NGX_MODULE_V1,
+    &ngx_ssl_engine_dasync_module_ctx,      /* module context */
+    ngx_ssl_engine_dasync_commands,         /* module directives */
+    NGX_SSL_ENGINE_MODULE,                  /* module type */
+    NULL,                                   /* init master */
+    NULL,                                   /* init module */
+    NULL,                                   /* init process */
+    NULL,                                   /* init thread */
+    NULL,                                   /* exit thread */
+    ngx_ssl_engine_dasync_process_exit,     /* exit process */
+    NULL,                                   /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static ngx_int_t
+ngx_ssl_engine_dasync_send_ctrl(ngx_cycle_t *cycle)
+{
+    const char *engine_id = "dasync";
+    ENGINE     *e;
+
+    e = ENGINE_by_id(engine_id);
+    if (e == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "ENGINE_by_id(\"dasync\") failed");
+        return NGX_ERROR;
+    }
+
+    /* send ctrl before engine init */
+
+    /* ssl engine global variable set */
+
+    ENGINE_free(e);
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_ssl_engine_dasync_register_handler(ngx_cycle_t *cycle)
+{
+
+    /* set corresponding handler, e.g., external poll handler */
+
+    return NGX_OK;
+}
+
+
+static char *
+ngx_ssl_engine_dasync_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char           *rv;
+    ngx_conf_t      pcf;
+
+    pcf = *cf;
+    cf->cmd_type = NGX_SSL_ENGINE_SUB_CONF;
+
+    rv = ngx_conf_parse(cf, NULL);
+
+    *cf = pcf;
+
+    if (rv != NGX_CONF_OK) {
+        return rv;
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static void *
+ngx_ssl_engine_dasync_create_conf(ngx_cycle_t *cycle)
+{
+    ngx_ssl_engine_dasync_conf_t  *sedcf;
+
+    sedcf = ngx_pcalloc(cycle->pool, sizeof(ngx_ssl_engine_dasync_conf_t));
+    if (sedcf == NULL) {
+        return NULL;
+    }
+
+    /*
+     * set by ngx_pcalloc():
+     *
+     *     sedcf->offload_mode = NULL
+     *     sedcf->notify_mode = NULL
+     *     sedcf->poll_mode = NULL
+     */
+
+    return sedcf;
+}
+
+
+static char *
+ngx_ssl_engine_dasync_init_conf(ngx_cycle_t *cycle, void *conf)
+{
+    ngx_ssl_engine_dasync_conf_t *sedcf = conf;
+
+    /* init the conf values not set by the user */
+
+    ngx_conf_init_str_value(sedcf->offload_mode, "async");
+
+    /* check the validity of the conf values */
+
+    if (ngx_strcmp(sedcf->offload_mode.data, "async") != 0) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "wrong type for dasync_offload_mode");
+        return NGX_CONF_ERROR;
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static void
+ngx_ssl_engine_dasync_process_exit(ngx_cycle_t *cycle)
+{
+    ENGINE_cleanup();
+}
diff --git a/src/engine/ngx_ssl_engine.c b/src/engine/ngx_ssl_engine.c
new file mode 100644
index 000000000..6f5a18568
--- /dev/null
+++ b/src/engine/ngx_ssl_engine.c
@@ -0,0 +1,547 @@
+/* ====================================================================
+ *
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2016-2021 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ * ====================================================================
+ */
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_ssl_engine.h>
+
+
+static char *ngx_ssl_engine_block(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static ngx_int_t ngx_ssl_engine_process_init(ngx_cycle_t *cycle);
+static void ngx_ssl_engine_master_exit(ngx_cycle_t *cycle);
+
+static char *ngx_ssl_engine_use(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static char *ngx_ssl_engine_default_algorithms(ngx_conf_t *cf,
+    ngx_command_t *cmd, void *conf);
+
+static void *ngx_ssl_engine_core_create_conf(ngx_cycle_t *cycle);
+
+static void ngx_ssl_engine_table_cleanup(ENGINE *e);
+static char * ngx_ssl_engine_init_check(ngx_cycle_t *cycle, void *conf);
+
+/* indicating whether to use ssl engine: 0 or 1 */
+ngx_uint_t                  ngx_use_ssl_engine;
+
+ngx_ssl_engine_actions_t    ngx_ssl_engine_actions;
+ngx_uint_t                  ngx_ssl_engine_enable_heuristic_polling;
+
+ngx_str_t                   ngx_ssl_engine_name_curr = {
+    0,
+    NULL
+};
+ngx_str_t                   ngx_ssl_engine_name_prev = {
+    0,
+    NULL
+};
+
+ngx_flag_t                  ngx_ssl_engine_reload_processed = 0;
+ngx_flag_t                  ngx_ssl_engine_need_finished = 0;
+
+static ngx_command_t  ngx_ssl_engine_commands[] = {
+
+    { ngx_string("ssl_engine"),
+      NGX_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,
+      ngx_ssl_engine_block,
+      0,
+      0,
+      NULL },
+
+      ngx_null_command
+};
+
+static ngx_core_module_t  ngx_ssl_engine_module_ctx = {
+    ngx_string("ssl_engine"),
+    NULL,
+    ngx_ssl_engine_init_check
+};
+
+ngx_module_t  ngx_ssl_engine_module = {
+    NGX_MODULE_V1,
+    &ngx_ssl_engine_module_ctx,            /* module context */
+    ngx_ssl_engine_commands,               /* module directives */
+    NGX_CORE_MODULE,                       /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    ngx_ssl_engine_process_init,           /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    ngx_ssl_engine_master_exit,            /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static ngx_str_t ssl_engine_core_name = ngx_string("ssl_engine_core");
+
+static ngx_command_t  ngx_ssl_engine_core_commands[] = {
+
+    { ngx_string("use_engine"),
+      NGX_SSL_ENGINE_CONF|NGX_CONF_TAKE12,
+      ngx_ssl_engine_use,
+      0,
+      0,
+      NULL },
+
+    { ngx_string("default_algorithms"),
+      NGX_SSL_ENGINE_CONF|NGX_CONF_1MORE,
+      ngx_ssl_engine_default_algorithms,
+      0,
+      offsetof(ngx_ssl_engine_conf_t, default_algorithms),
+      NULL },
+
+      ngx_null_command
+};
+
+ngx_ssl_engine_module_t  ngx_ssl_engine_core_module_ctx = {
+    &ssl_engine_core_name,
+    ngx_ssl_engine_core_create_conf,        /* create configuration */
+    NULL,                                   /* init configuration */
+
+    { NULL, NULL, NULL, NULL, NULL }
+};
+
+ngx_module_t  ngx_ssl_engine_core_module = {
+    NGX_MODULE_V1,
+    &ngx_ssl_engine_core_module_ctx,        /* module context */
+    ngx_ssl_engine_core_commands,           /* module directives */
+    NGX_SSL_ENGINE_MODULE,                  /* module type */
+    NULL,                                   /* init master */
+    NULL,                                   /* init module */
+    NULL,                                   /* init process */
+    NULL,                                   /* init thread */
+    NULL,                                   /* exit thread */
+    NULL,                                   /* exit process */
+    NULL,                                   /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+/* OpenSSL will register all dynamic engines into its global engine tables
+ * To support dynamically update engine configuration such as default_algorithm
+ * It needs to unregister all algorithms before applying new configuration
+ * Especially for remove some algorithms from previous configuration
+ */
+static void
+ngx_ssl_engine_table_cleanup(ENGINE *e)
+{
+    ENGINE_unregister_ciphers(e);
+    ENGINE_unregister_digests(e);
+    ENGINE_unregister_pkey_meths(e);
+    ENGINE_unregister_DSA(e);
+    ENGINE_unregister_EC(e);
+    ENGINE_unregister_RSA(e);
+    ENGINE_unregister_DH(e);
+}
+
+char *
+ngx_ssl_engine_name_record(ngx_str_t *name, ngx_pool_t *pool)
+{
+    ngx_memzero(&ngx_ssl_engine_name_prev, sizeof(ngx_ssl_engine_name_prev));
+    if (NULL != ngx_ssl_engine_name_curr.data &&
+        0 < ngx_ssl_engine_name_curr.len) {
+        ngx_ssl_engine_name_prev.data = ngx_pcalloc(pool, (ngx_ssl_engine_name_curr.len + 1));
+        ngx_ssl_engine_name_prev.len = ngx_ssl_engine_name_curr.len;
+        ngx_sprintf(ngx_ssl_engine_name_prev.data, "%s", ngx_ssl_engine_name_curr.data);
+    }
+
+    if (NULL == name) {
+        ngx_memzero(&ngx_ssl_engine_name_curr, sizeof(ngx_ssl_engine_name_curr));
+    } else {
+        ngx_ssl_engine_name_curr.data = ngx_pcalloc(pool, (name->len + 1));
+        ngx_ssl_engine_name_curr.len = name->len;
+        ngx_sprintf(ngx_ssl_engine_name_curr.data, "%s", name->data);
+    }
+
+    return NGX_CONF_OK;
+}
+
+char *
+ngx_ssl_engine_unload_check(ngx_cycle_t *cycle)
+{
+    ENGINE      *e;
+
+    if (NGX_PROCESS_SINGLE == ngx_process ||
+        NGX_PROCESS_MASTER == ngx_process) {
+        if (ngx_ssl_engine_reload_processed) {
+            return NGX_CONF_OK;
+        }
+        ngx_ssl_engine_reload_processed = 1;
+
+        if (NULL == ngx_get_conf(cycle->conf_ctx, ngx_ssl_engine_module)) {
+            ngx_ssl_engine_name_record(NULL, cycle->pool);
+        }
+
+        if(ngx_use_ssl_engine &&
+            NULL != ngx_ssl_engine_name_prev.data &&
+            0 < ngx_ssl_engine_name_prev.len &&
+            0 == ngx_ssl_engine_name_curr.len) {
+            ngx_memzero(&ngx_ssl_engine_actions, sizeof(ngx_ssl_engine_actions));
+            ngx_use_ssl_engine = 0;
+        }
+    }
+
+    if(0 == ngx_ssl_engine_name_prev.len ||
+        NULL == ngx_ssl_engine_name_prev.data) {
+        return NGX_CONF_OK;
+    }
+
+    if ((0 == ngx_ssl_engine_name_curr.len) ||
+        (0 < ngx_ssl_engine_name_curr.len &&
+        NULL != ngx_ssl_engine_name_curr.data &&
+        0 != ngx_strcmp(ngx_ssl_engine_name_curr.data, ngx_ssl_engine_name_prev.data))) {
+
+            e = ENGINE_by_id((const char *)ngx_ssl_engine_name_prev.data);
+            if (e == NULL) {
+                ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                            "ENGINE_by_id(\"%s\") failed", (const char *)ngx_ssl_engine_name_prev.data);
+                return NGX_CONF_ERROR;
+            }
+
+            ngx_ssl_engine_table_cleanup(e);
+            ENGINE_GEN_INT_FUNC_PTR finish_function = ENGINE_get_finish_function(e);
+            finish_function(e);
+
+            if (NGX_PROCESS_SINGLE == ngx_process ||
+                NGX_PROCESS_MASTER == ngx_process) {
+                ENGINE_finish(e);
+                ENGINE_cleanup();
+            }
+            ENGINE_free(e);
+    }
+
+    return NGX_CONF_OK;
+}
+
+ngx_int_t
+ngx_ssl_engine_set(ngx_cycle_t *cycle)
+{
+    ngx_ssl_engine_conf_t *secf;
+
+    ENGINE      *e;
+    ngx_str_t   *value;
+    ngx_uint_t   i;
+
+
+    if (ngx_ssl_engine_send_ctrl(cycle) != NGX_OK) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "ssl engine send ctrl failed");
+        return NGX_ERROR;
+    }
+
+    secf = ngx_engine_cycle_get_conf(cycle, ngx_ssl_engine_core_module);
+    if (secf == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                     "conf of engine_core_module is null");
+        return NGX_ERROR;
+    }
+
+    e = ENGINE_by_id((const char *) secf->ssl_engine_id.data);
+
+    if (e == NULL) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                      "ENGINE_by_id(\"%V\") failed", &secf->ssl_engine_id);
+        return NGX_ERROR;
+    }
+
+    /* Cleanup OpenSSL engine tables */
+    ngx_ssl_engine_table_cleanup(e);
+
+    /* The ENGINE_finish is not executed by master process before the Nginx
+     * reload, which causes the worker can't exit gracefully due to unreleased
+     * resources. Run ENGINE_finish for master process here when reload happens
+     * to cover such case.
+     * */
+    if (NGX_PROCESS_SINGLE == ngx_process ||
+        NGX_PROCESS_MASTER == ngx_process) {
+        if (ngx_ssl_engine_need_finished) {
+            ENGINE_finish(e);
+        }
+        else {
+            ngx_ssl_engine_need_finished = 1;
+        }
+    }
+
+    if (!ENGINE_init(e)) {
+        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0, "engine init failed");
+        ENGINE_free(e);
+        return NGX_ERROR;
+    }
+
+    if (secf->default_algorithms != NGX_CONF_UNSET_PTR) {
+        value = secf->default_algorithms->elts;
+        for (i = 0; i < secf->default_algorithms->nelts; i++) {
+            if (!ENGINE_set_default_string(e, (const char *) value[i].data)) {
+                ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                              "ENGINE_set_default_string failed");
+                ENGINE_free(e);
+                return NGX_ERROR;
+            }
+        }
+    } else {
+        if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "ENGINE_set_default failed");
+            ENGINE_free(e);
+            return NGX_ERROR;
+        }
+    }
+
+    ENGINE_free(e);
+    return NGX_OK;
+}
+
+
+static char *
+ngx_ssl_engine_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char           *rv;
+    void         ***ctx;
+    ngx_uint_t      i;
+    ngx_uint_t      ngx_ssl_engine_max_module;
+    ngx_conf_t      pcf;
+
+    ngx_ssl_engine_module_t     *m;
+
+    if (*(void **) conf) {
+        return "is duplicate";
+    }
+
+    /* count the number of the engine modules and set up their indices */
+
+    ngx_ssl_engine_max_module = ngx_count_modules(cf->cycle,
+                                                  NGX_SSL_ENGINE_MODULE);
+
+    ctx = ngx_pcalloc(cf->pool, sizeof(void *));
+    if (ctx == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    *ctx = ngx_pcalloc(cf->pool, ngx_ssl_engine_max_module * sizeof(void *));
+    if (*ctx == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    *(void **) conf = ctx;
+
+    for (i = 0; cf->cycle->modules[i]; i++) {
+        if (cf->cycle->modules[i]->type != NGX_SSL_ENGINE_MODULE) {
+            continue;
+        }
+
+        m = cf->cycle->modules[i]->ctx;
+
+        if (m->create_conf) {
+            (*ctx)[cf->cycle->modules[i]->ctx_index] =
+                                                     m->create_conf(cf->cycle);
+            if ((*ctx)[cf->cycle->modules[i]->ctx_index] == NULL) {
+                return NGX_CONF_ERROR;
+            }
+        }
+    }
+
+    pcf = *cf;
+    cf->ctx = ctx;
+    cf->module_type = NGX_SSL_ENGINE_MODULE;
+    cf->cmd_type = NGX_SSL_ENGINE_CONF;
+
+    rv = ngx_conf_parse(cf, NULL);
+
+    *cf = pcf;
+
+    if (rv != NGX_CONF_OK) {
+        return rv;
+    }
+
+    for (i = 0; cf->cycle->modules[i]; i++) {
+        if (cf->cycle->modules[i]->type != NGX_SSL_ENGINE_MODULE) {
+            continue;
+        }
+
+        m = cf->cycle->modules[i]->ctx;
+
+        if (m->init_conf) {
+            rv = m->init_conf(cf->cycle,
+                              (*ctx)[cf->cycle->modules[i]->ctx_index]);
+            if (rv != NGX_CONF_OK) {
+                return rv;
+            }
+        }
+    }
+
+#if 0
+    /* ssl engine set must before parsing http conf */
+    if (ngx_use_ssl_engine && !cf->cycle->no_ssl_init) {
+        if (ngx_ssl_engine_set(cf->cycle) != NGX_OK) {
+            ngx_log_error(NGX_LOG_EMERG, cf->log, 0, "ssl engine set failed");
+            return NGX_CONF_ERROR;
+        }
+    }
+#endif
+
+    return NGX_CONF_OK;
+}
+
+static char *
+ngx_ssl_engine_init_check(ngx_cycle_t *cycle, void *conf)
+{
+    return ngx_ssl_engine_unload_check(cycle);
+}
+
+static ngx_int_t
+ngx_ssl_engine_process_init(ngx_cycle_t *cycle)
+{
+    ngx_ssl_engine_unload_check(cycle);
+
+    if (ngx_use_ssl_engine) {
+        if (ngx_ssl_engine_register_handler(cycle) != NGX_OK) {
+            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,
+                          "ssl engine register handler failed");
+            return NGX_ERROR;
+        }
+    }
+
+    return NGX_OK;
+}
+
+
+static void
+ngx_ssl_engine_master_exit(ngx_cycle_t *cycle)
+{
+#if OPENSSL_VERSION_NUMBER < 0x10100003L
+    EVP_cleanup();
+#endif
+    ENGINE_cleanup();
+}
+
+
+static char *
+ngx_ssl_engine_use(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_ssl_engine_conf_t  *secf = conf;
+
+    ngx_int_t                 m;
+    ngx_str_t                *value;
+    ngx_ssl_engine_module_t  *module;
+
+    if (secf->ssl_engine_id.len != 0) {
+        return "is duplicate";
+    }
+
+    value = cf->args->elts;
+
+    for (m = 0; cf->cycle->modules[m]; m++) {
+        if (cf->cycle->modules[m]->type != NGX_SSL_ENGINE_MODULE) {
+            continue;
+        }
+
+        module = cf->cycle->modules[m]->ctx;
+        if (module->name->len == value[1].len) {
+            if (ngx_strcmp(module->name->data, value[1].data) == 0) {
+                if (3 == cf->args->nelts) {
+                    secf->ssl_engine_id = value[2];
+                } else {
+                    secf->ssl_engine_id = value[1];
+                }
+                ngx_use_ssl_engine = 1;
+                ngx_ssl_engine_actions = module->actions;
+
+                ngx_ssl_engine_name_record(module->name, cf->pool);
+
+                return NGX_CONF_OK;
+            }
+        }
+    }
+
+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                       "invalid engine type \"%V\"", &value[1]);
+
+    return NGX_CONF_ERROR;
+}
+
+
+static char *
+ngx_ssl_engine_default_algorithms(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    char *p = conf;
+
+    ngx_str_t          *value, *s;
+    ngx_array_t       **a;
+    ngx_uint_t          i;
+
+    a = (ngx_array_t **) (p + cmd->offset);
+
+    if (*a == NGX_CONF_UNSET_PTR) {
+        *a = ngx_array_create(cf->pool, cf->args->nelts - 1, sizeof(ngx_str_t));
+        if (*a == NULL) {
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    value = cf->args->elts;
+
+    for (i = 1; i < cf->args->nelts; i++) {
+        s = ngx_array_push(*a);
+        if (s == NULL) {
+            return NGX_CONF_ERROR;
+        }
+        *s = value[i];
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static void *
+ngx_ssl_engine_core_create_conf(ngx_cycle_t *cycle)
+{
+    ngx_ssl_engine_conf_t  *secf;
+
+    secf = ngx_pcalloc(cycle->pool, sizeof(ngx_ssl_engine_conf_t));
+    if (secf == NULL) {
+        return NULL;
+    }
+
+    /* ngx_pcalloc makes secf->ssl_engine_id.len = 0 */
+    ngx_use_ssl_engine = 0;
+    ngx_ssl_engine_enable_heuristic_polling = 0;
+    secf->default_algorithms = NGX_CONF_UNSET_PTR;
+
+    return secf;
+}
diff --git a/src/engine/ngx_ssl_engine.h b/src/engine/ngx_ssl_engine.h
new file mode 100644
index 000000000..20e4c2915
--- /dev/null
+++ b/src/engine/ngx_ssl_engine.h
@@ -0,0 +1,102 @@
+/* ====================================================================
+ *
+ *
+ *   BSD LICENSE
+ *
+ *   Copyright(c) 2016-2021 Intel Corporation.
+ *   All rights reserved.
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
+ *   are met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
+ *       distribution.
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ * ====================================================================
+ */
+
+#ifndef _NGX_ENGINE_H_INCLUDED_
+#define _NGX_ENGINE_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+
+typedef struct {
+    ngx_int_t  (*init)(ngx_cycle_t *cycle);
+    ngx_int_t  (*send_ctrl)(ngx_cycle_t *cycle);
+    ngx_int_t  (*register_handler)(ngx_cycle_t *cycle);
+    ngx_int_t  (*release)(ngx_cycle_t *cycle);
+    void       (*heuristic_poll)(ngx_log_t *log);
+} ngx_ssl_engine_actions_t;
+
+extern ngx_uint_t                       ngx_use_ssl_engine;
+extern ngx_ssl_engine_actions_t         ngx_ssl_engine_actions;
+extern ngx_uint_t                       ngx_ssl_engine_enable_heuristic_polling;
+extern ngx_flag_t                       ngx_ssl_engine_reload_processed;
+
+#define ngx_ssl_engine_init             ngx_ssl_engine_actions.init
+#define ngx_ssl_engine_send_ctrl        ngx_ssl_engine_actions.send_ctrl
+#define ngx_ssl_engine_register_handler ngx_ssl_engine_actions.register_handler
+#define ngx_ssl_engine_release          ngx_ssl_engine_actions.release
+#define ngx_ssl_engine_heuristic_poll   ngx_ssl_engine_actions.heuristic_poll
+
+#define NGX_SSL_ENGINE_MODULE           0x55555555
+#define NGX_SSL_ENGINE_CONF             0x02000000
+#define NGX_SSL_ENGINE_SUB_CONF         0x04000000
+
+typedef struct {
+    ngx_str_t        ssl_engine_id;
+    ngx_array_t     *default_algorithms;
+} ngx_ssl_engine_conf_t;
+
+
+typedef struct {
+    ngx_str_t                  *name;
+
+    void                     *(*create_conf)(ngx_cycle_t *cycle);
+    char                     *(*init_conf)(ngx_cycle_t *cycle, void *conf);
+
+    ngx_ssl_engine_actions_t    actions;
+} ngx_ssl_engine_module_t;
+
+
+extern ngx_module_t     ngx_ssl_engine_module;
+extern ngx_module_t     ngx_ssl_engine_core_module;
+
+
+#define ngx_engine_ctx_get_conf(conf_ctx, module)                          \
+    (*(ngx_get_conf(conf_ctx, ngx_ssl_engine_module))) [module.ctx_index];
+
+#define ngx_engine_cycle_get_conf(cycle, module)                           \
+    (cycle->conf_ctx[ngx_ssl_engine_module.index] ?                        \
+        (*(ngx_get_conf(cycle->conf_ctx, ngx_ssl_engine_module)))          \
+            [module.ctx_index]:                                            \
+        NULL)
+
+char * ngx_ssl_engine_unload_check(ngx_cycle_t *cycle);
+ngx_int_t ngx_ssl_engine_set(ngx_cycle_t *cycle);
+
+#endif /* _NGX_ENGINE_H_INCLUDED_ */
diff --git a/src/event/modules/ngx_devpoll_module.c b/src/event/modules/ngx_devpoll_module.c
index 590eb28e1..13bdc9caa 100644
--- a/src/event/modules/ngx_devpoll_module.c
+++ b/src/event/modules/ngx_devpoll_module.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -94,6 +95,8 @@ static ngx_event_module_t  ngx_devpoll_module_ctx = {
         ngx_devpoll_process_events,        /* process the events */
         ngx_devpoll_init,                  /* init the events */
         ngx_devpoll_done,                  /* done the events */
+        NULL,                              /* add an async conn */
+        NULL                               /* del an async conn */
     }

 };
diff --git a/src/event/modules/ngx_epoll_module.c b/src/event/modules/ngx_epoll_module.c
index 98e3ce7c8..417266299 100644
--- a/src/event/modules/ngx_epoll_module.c
+++ b/src/event/modules/ngx_epoll_module.c
@@ -2,13 +2,14 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


 #include <ngx_config.h>
 #include <ngx_core.h>
 #include <ngx_event.h>
-
+extern pthread_mutex_t queue_lock;

 #if (NGX_TEST_BUILD_EPOLL)

@@ -35,6 +36,7 @@
 #define EPOLL_CTL_DEL  2
 #define EPOLL_CTL_MOD  3

+
 typedef union epoll_data {
     void         *ptr;
     int           fd;
@@ -122,6 +124,14 @@ static ngx_int_t ngx_epoll_notify(ngx_event_handler_pt handler);
 #endif
 static ngx_int_t ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,
     ngx_uint_t flags);
+static ngx_int_t ngx_epoll_process_callback(ngx_cycle_t *cycle, ngx_msec_t timer,
+    ngx_uint_t flags);
+static ngx_int_t ngx_epoll_add_async_conn_to_q(ngx_connection_t *c);
+#if (NGX_SSL)
+static ngx_int_t ngx_epoll_add_async_connection(ngx_connection_t *c);
+static ngx_int_t ngx_epoll_del_async_connection(ngx_connection_t *c,
+    ngx_uint_t flags);
+#endif

 #if (NGX_HAVE_FILE_AIO)
 static void ngx_epoll_eventfd_handler(ngx_event_t *ev);
@@ -194,8 +204,17 @@ static ngx_event_module_t  ngx_epoll_module_ctx = {
         NULL,                            /* trigger a notify */
 #endif
         ngx_epoll_process_events,        /* process the events */
+        ngx_epoll_process_callback,        /* process the events */
         ngx_epoll_init,                  /* init the events */
         ngx_epoll_done,                  /* done the events */
+	ngx_epoll_add_async_conn_to_q,
+#if (NGX_SSL)
+        ngx_epoll_add_async_connection,  /* add an async conn */
+        ngx_epoll_del_async_connection   /* del an async conn */
+#else
+        NULL,                            /* add an async conn */
+        NULL                             /* del an async conn */
+#endif
     }
 };

@@ -623,13 +642,11 @@ ngx_epoll_add_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
     ngx_log_debug3(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                    "epoll add event: fd:%d op:%d ev:%08XD",
                    c->fd, op, ee.events);
-
     if (epoll_ctl(ep, op, c->fd, &ee) == -1) {
         ngx_log_error(NGX_LOG_ALERT, ev->log, ngx_errno,
-                      "epoll_ctl(%d, %d) failed", op, c->fd);
+                      "socket add event epoll_ctl(%d, %d) failed", op, c->fd);
         return NGX_ERROR;
     }
-
     ev->active = 1;
 #if 0
     ev->oneshot = (flags & NGX_ONESHOT_EVENT) ? 1 : 0;
@@ -684,13 +701,11 @@ ngx_epoll_del_event(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags)
     ngx_log_debug3(NGX_LOG_DEBUG_EVENT, ev->log, 0,
                    "epoll del event: fd:%d op:%d ev:%08XD",
                    c->fd, op, ee.events);
-
     if (epoll_ctl(ep, op, c->fd, &ee) == -1) {
         ngx_log_error(NGX_LOG_ALERT, ev->log, ngx_errno,
-                      "epoll_ctl(%d, %d) failed", op, c->fd);
+                      "socket del event epoll_ctl(%d, %d) failed", op, c->fd);
         return NGX_ERROR;
     }
-
     ev->active = 0;

     return NGX_OK;
@@ -707,13 +722,11 @@ ngx_epoll_add_connection(ngx_connection_t *c)

     ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,
                    "epoll add connection: fd:%d ev:%08XD", c->fd, ee.events);
-
     if (epoll_ctl(ep, EPOLL_CTL_ADD, c->fd, &ee) == -1) {
         ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
-                      "epoll_ctl(EPOLL_CTL_ADD, %d) failed", c->fd);
+                      "socket add_conn epoll_ctl(EPOLL_CTL_ADD, %d) failed", c->fd);
         return NGX_ERROR;
     }
-
     c->read->active = 1;
     c->write->active = 1;

@@ -742,13 +755,14 @@ ngx_epoll_del_connection(ngx_connection_t *c, ngx_uint_t flags)
     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
                    "epoll del connection: fd:%d", c->fd);

+    //fprintf(stderr, "%s == epoll del connection: fd:%d\n", __func__,c->fd);
     op = EPOLL_CTL_DEL;
     ee.events = 0;
     ee.data.ptr = NULL;

     if (epoll_ctl(ep, op, c->fd, &ee) == -1) {
         ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
-                      "epoll_ctl(%d, %d) failed", op, c->fd);
+                     "socket del conn epoll_ctl(%d, %d) failed", op, c->fd);
         return NGX_ERROR;
     }

@@ -758,6 +772,144 @@ ngx_epoll_del_connection(ngx_connection_t *c, ngx_uint_t flags)
     return NGX_OK;
 }

+#define MAX_SIZE 1000000
+uint64_t arr_queue[MAX_SIZE];
+static int rear = -1, front = -1;
+
+int manage_queue(uint64_t val, uint8_t op) {
+    uint64_t item;
+    int choice, i;
+
+	choice = op;
+        switch (choice) {
+            case 1:
+		 if((front == 0 && rear == MAX_SIZE-1) || (front == rear+1))
+		 {
+		     fprintf(stderr, "\n%s | Queue Overflow n", __func__);
+		     return -1;
+		 }
+		item = val;
+		 if(front == -1)
+		 {
+			 front = 0;
+			 rear = 0;
+			//fprintf(stderr, "\n%s | Insert | ## Position : %d , Insert conn addr  : %lx ", __func__, rear + 1, item);
+		 } else {
+			rear = rear + 1;
+			 if (rear == MAX_SIZE) {
+				 //fprintf(stderr, "\n%s | Insert | ## Queue Reached Max!!", __func__);
+				 rear = 0;
+			 }/* else {
+				 //fprintf(stderr, "\n%s | Insert | ## Position : %d , Insert conn addr  : %lx ", __func__, rear + 1, item);
+				 //rear = rear + 1;
+			 }*/
+		 }
+		arr_queue[rear] = item;
+                break;
+            case 2:
+		if(front == -1)
+		{
+			fprintf(stderr, "\n %s | Queue Underflown", __func__);
+			return -1;
+		}
+		if (front == rear) {
+			//fprintf(stderr, "\n %s | Delete | ## Queue is Empty!. No conn addr \n", __func__);
+			front = -1;
+			rear = -1;
+		} else {
+			//fprintf(stderr, "\n %s | Delete | ## Position : %d , Remove conn addr  : %lx \n", __func__, front, arr_queue[front]);
+			front = front+1;
+			if(front == MAX_SIZE)
+				front = 0;
+                }
+                break;
+            case 3:
+                fprintf(stderr, "\n%s | Display | ## Total connection Addresses : %d front:%d | rear:%d \n", __func__, rear > front?(rear-front):((MAX_SIZE-front)+rear), front, rear);
+		if (front <= rear) {
+			for (i = front; i <= rear; i++)
+				fprintf(stderr, "\n	Position : %d , conn addr  : %lx ", i, arr_queue[i]);
+		} else {
+			int front_pos = front,rear_pos = rear;
+			while(front_pos < MAX_SIZE)
+			{
+
+				fprintf(stderr, "\n 	Position :%d | %lx ", front_pos, arr_queue[front_pos]);
+					front_pos++;
+			}
+			front_pos = 0;
+			while(front_pos <= rear_pos)
+			{
+				fprintf(stderr, "\n	Position:%d | %lx ", front_pos , arr_queue[front_pos]);
+				front_pos++;
+			}
+			fprintf(stderr, "\n");
+		}
+                break;
+            default:
+                break;
+        }
+
+    return 0;
+}
+
+static ngx_int_t
+ngx_epoll_add_async_conn_to_q(ngx_connection_t *c)
+{
+	//fprintf(stderr, "\nInside %s\n", __func__);
+	//pthread_mutex_lock(&queue_lock);
+	manage_queue((uint64_t)c, 1);
+	//manage_queue((uint64_t)c, 3);
+	//pthread_mutex_unlock(&queue_lock);
+	return 0;
+}
+
+#if (NGX_SSL)
+static ngx_int_t
+ngx_epoll_add_async_connection(ngx_connection_t *c)
+{
+    struct epoll_event  ee;
+
+    ee.events = EPOLLIN|EPOLLOUT|EPOLLET|EPOLLRDHUP;
+    ee.data.ptr = (void *) ((uintptr_t) c | (c->async->async << 1) | c->async->instance);
+
+    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                   "epoll add async connection: fd:%d ev:%08XD", c->async_fd, ee.events);
+    if (epoll_ctl(ep, EPOLL_CTL_ADD, c->async_fd, &ee) == -1) {
+        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
+                      "async add conn epoll_ctl(EPOLL_CTL_ADD, %d) failed", c->async_fd);
+        return NGX_ERROR;
+    }
+
+    c->async->active = 1;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_epoll_del_async_connection(ngx_connection_t *c, ngx_uint_t flags)
+{
+    int                 op;
+    struct epoll_event  ee;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                   "epoll del async connection: fd:%d", c->async_fd);
+
+    op = EPOLL_CTL_DEL;
+    ee.events = 0;
+    ee.data.ptr = NULL;
+    if (epoll_ctl(ep, op, c->async_fd, &ee) == -1) {
+        ngx_log_error(NGX_LOG_ALERT, c->log, ngx_errno,
+                      "async del conn epoll_ctl(%d, %d) failed", op, c->async_fd);
+        c->async_fd = -1;
+        return NGX_ERROR;
+    }
+    c->async_fd = -1;
+    c->async->active = 0;
+
+    return NGX_OK;
+}
+#endif

 #if (NGX_HAVE_EVENTFD)

@@ -779,24 +931,91 @@ ngx_epoll_notify(ngx_event_handler_pt handler)

 #endif

-
+static ngx_int_t
+ngx_epoll_process_callback(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags) {
+	int j;
+	ngx_connection_t  *conn;
+	ngx_event_t       *conn_aev;
+	//fprintf(stderr, "Entering %s | front:%d | rear:%d \n", __func__, front, rear);
+
+	if ((front != -1) && (rear != -1)) {
+		//manage_queue(0, 3);
+		if (front <= rear) {
+			for (j = front; j <= rear; j++) {
+				conn = (ngx_connection_t *)arr_queue[j];
+				conn_aev = conn->async;
+				conn_aev->ready = 1;
+				//fprintf(stderr, "\nfront <= rear case | Connection Address:%lx\n", arr_queue[j]);
+				conn_aev->handler(conn_aev);
+				//pthread_mutex_lock(&queue_lock);
+				manage_queue(0, 2);
+				//pthread_mutex_unlock(&queue_lock);
+			}
+		} else {
+			int front_pos = front,rear_pos = rear;
+			while(front_pos < MAX_SIZE)
+			{
+
+				conn = (ngx_connection_t *)arr_queue[front_pos];
+				conn_aev = conn->async;
+				conn_aev->ready = 1;
+				//fprintf(stderr, "\nfront > rear case | Connection Address:%lx\n", arr_queue[front_pos]);
+				conn_aev->handler(conn_aev);
+				//pthread_mutex_lock(&queue_lock);
+				manage_queue(0, 2);
+				//pthread_mutex_unlock(&queue_lock);
+
+				front_pos++;
+			}
+			front_pos = 0;
+			while(front_pos <= rear_pos)
+			{
+				conn = (ngx_connection_t *)arr_queue[front_pos];
+				conn_aev = conn->async;
+				conn_aev->ready = 1;
+				//fprintf(stderr, "\nfront > rear case | Connection Address:%lx\n", arr_queue[front_pos]);
+				conn_aev->handler(conn_aev);
+				//pthread_mutex_lock(&queue_lock);
+				manage_queue(0, 2);
+				//pthread_mutex_unlock(&queue_lock);
+				front_pos++;
+			}
+		}
+
+	}
+	//fprintf(stderr, "<<<<Returning from %s | front:%d | rear:%d \n", __func__, front, rear);
+	return 0;
+}
 static ngx_int_t
 ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)
 {
-    int                events;
+    int                events/*, j*/;
     uint32_t           revents;
     ngx_int_t          instance, i;
     ngx_uint_t         level;
     ngx_err_t          err;
     ngx_event_t       *rev, *wev;
     ngx_queue_t       *queue;
-    ngx_connection_t  *c;
+    ngx_connection_t  *c/*, *conn*/;
+#if (NGX_SSL)
+    ngx_int_t          async;
+    ngx_event_t       *aev/*, *conn_aev*/;
+#endif

     /* NGX_TIMER_INFINITE == INFTIM */

     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
                    "epoll timer: %M", timer);

+#if 0
+    fprintf(stderr, "Inside %s | front:%d | rear:%d \n", __func__, front, rear);
+    for(j=front; j<rear; j++) {
+	    conn = (ngx_connection_t *)arr_queue[j];
+	    conn_aev = conn->async;
+	    conn_aev->handler(conn_aev);
+	    manage_queue(0, 2);
+    }
+#endif
     events = epoll_wait(ep, event_list, (int) nevents, timer);

     err = (events == -1) ? ngx_errno : 0;
@@ -837,7 +1056,12 @@ ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)
         c = event_list[i].data.ptr;

         instance = (uintptr_t) c & 1;
+#if (NGX_SSL)
+        async = ((uintptr_t) c & 2) >> 1;
+        c = (ngx_connection_t *) ((uintptr_t) c & (uintptr_t) ~3);
+#else
         c = (ngx_connection_t *) ((uintptr_t) c & (uintptr_t) ~1);
+#endif

         rev = c->read;

@@ -880,7 +1104,11 @@ ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)
         }
 #endif

+#if (NGX_SSL)
+        if ((revents & EPOLLIN) && rev->active && !async) {
+#else
         if ((revents & EPOLLIN) && rev->active) {
+#endif

 #if (NGX_HAVE_EPOLLRDHUP)
             if (revents & EPOLLRDHUP) {
@@ -904,7 +1132,11 @@ ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)

         wev = c->write;

+#if (NGX_SSL)
+        if ((revents & EPOLLOUT) && wev->active && !async) {
+#else
         if ((revents & EPOLLOUT) && wev->active) {
+#endif

             if (c->fd == -1 || wev->instance != instance) {

@@ -930,6 +1162,33 @@ ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)
                 wev->handler(wev);
             }
         }
+
+#if (NGX_SSL)
+        aev = c->async;
+
+        if ((revents & EPOLLIN) && aev->active && async) {
+
+            if (c->async_fd == -1 || aev->instance!= instance) {
+                /*
+                 * the stale event from a file descriptor
+                 * that was just closed in this iteration
+                 */
+
+                ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,
+                               "epoll: stale event %p", c);
+                continue;
+            }
+
+            aev->ready = 1;
+
+            if (flags & NGX_POST_EVENTS) {
+                ngx_post_event(aev, &ngx_posted_events);
+
+            } else {
+                aev->handler(aev);
+            }
+        }
+#endif
     }

     return NGX_OK;
diff --git a/src/event/modules/ngx_eventport_module.c b/src/event/modules/ngx_eventport_module.c
index d304e1c91..ae4beba2f 100644
--- a/src/event/modules/ngx_eventport_module.c
+++ b/src/event/modules/ngx_eventport_module.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -187,6 +188,8 @@ static ngx_event_module_t  ngx_eventport_module_ctx = {
         ngx_eventport_process_events,      /* process the events */
         ngx_eventport_init,                /* init the events */
         ngx_eventport_done,                /* done the events */
+        NULL,                              /* add an async conn */
+        NULL                               /* del an async conn */
     }

 };
diff --git a/src/event/modules/ngx_iocp_module.c b/src/event/modules/ngx_iocp_module.c
index b03944bb0..8f163e3e3 100644
--- a/src/event/modules/ngx_iocp_module.c
+++ b/src/event/modules/ngx_iocp_module.c
@@ -52,7 +52,7 @@ static ngx_command_t  ngx_iocp_commands[] = {
 };


-static ngx_event_module_t  ngx_iocp_module_ctx = {
+ngx_event_module_t  ngx_iocp_module_ctx = {
     &iocp_name,
     ngx_iocp_create_conf,                  /* create configuration */
     ngx_iocp_init_conf,                    /* init configuration */
@@ -93,8 +93,6 @@ ngx_os_io_t ngx_iocp_io = {
     NULL,
     ngx_udp_overlapped_wsarecv,
     NULL,
-    NULL,
-    NULL,
     ngx_overlapped_wsasend_chain,
     0
 };
diff --git a/src/event/modules/ngx_kqueue_module.c b/src/event/modules/ngx_kqueue_module.c
index 9c7244c45..66f11918a 100644
--- a/src/event/modules/ngx_kqueue_module.c
+++ b/src/event/modules/ngx_kqueue_module.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -34,6 +35,11 @@ static ngx_int_t ngx_kqueue_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,
     ngx_uint_t flags);
 static ngx_inline void ngx_kqueue_dump_event(ngx_log_t *log,
     struct kevent *kev);
+#if (NGX_SSL)
+static ngx_int_t ngx_kqueue_add_async_connection(ngx_connection_t *c);
+static ngx_int_t ngx_kqueue_del_async_connection(ngx_connection_t *c,
+    ngx_uint_t flags);
+#endif

 static void *ngx_kqueue_create_conf(ngx_cycle_t *cycle);
 static char *ngx_kqueue_init_conf(ngx_cycle_t *cycle, void *conf);
@@ -92,7 +98,14 @@ static ngx_event_module_t  ngx_kqueue_module_ctx = {
 #endif
         ngx_kqueue_process_events,         /* process the events */
         ngx_kqueue_init,                   /* init the events */
-        ngx_kqueue_done                    /* done the events */
+        ngx_kqueue_done,                   /* done the events */
+#if (NGX_SSL)
+        ngx_kqueue_add_async_connection,   /* add an async conn */
+        ngx_kqueue_del_async_connection    /* del an async conn */
+#else
+        NULL,                              /* add an async conn */
+        NULL                               /* del an async conn */
+#endif
     }

 };
@@ -421,7 +434,16 @@ ngx_kqueue_set_event(ngx_event_t *ev, ngx_int_t filter, ngx_uint_t flags)

     kev = &change_list[nchanges];

+#if (NGX_SSL)
+    if (ev->async) {
+        kev->ident = c->async_fd;
+    }
+    else {
+        kev->ident = c->fd;
+    }
+#else
     kev->ident = c->fd;
+#endif
     kev->filter = (short) filter;
     kev->flags = (u_short) flags;
     kev->udata = NGX_KQUEUE_UDATA_T ((uintptr_t) ev | ev->instance);
@@ -492,7 +514,67 @@ ngx_kqueue_notify(ngx_event_handler_pt handler)
 }

 #endif
+#if (NGX_SSL)
+static ngx_int_t
+ngx_kqueue_add_async_connection(ngx_connection_t *c)
+{
+    ngx_int_t          rc;
+    c->async->active = 1;
+    c->async->disabled = 0;
+
+    rc = ngx_kqueue_set_event(c->async, EVFILT_READ, EV_ADD|EV_ENABLE);

+    return rc;
+}
+
+static ngx_int_t
+ngx_kqueue_del_async_connection(ngx_connection_t *c, ngx_uint_t flags)
+{
+    ngx_int_t     rc;
+    ngx_event_t  *e;
+
+    c->async->active = 0;
+    c->async->disabled = 0;
+
+    if (c->async->index < nchanges
+        && ((uintptr_t) change_list[c->async->index].udata & (uintptr_t) ~1)
+            == (uintptr_t) c->async)
+    {
+        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->async->log, 0,
+                       "async kevent deleted: %d: ft:%i",
+                       ngx_event_ident(c->async->data), EVFILT_READ);
+        /* if the event is still not passed to a kernel we will not pass it */
+        nchanges--;
+
+        if (c->async->index < nchanges) {
+            e = (ngx_event_t *)
+                    ((uintptr_t) change_list[nchanges].udata & (uintptr_t) ~1);
+            change_list[c->async->index] = change_list[nchanges];
+            e->index = c->async->index;
+        }
+
+        return NGX_OK;
+    }
+
+    if (flags & NGX_CLOSE_EVENT) {
+        return NGX_OK;
+    }
+
+    if (flags & NGX_DISABLE_EVENT) {
+        c->async->disabled = 1;
+
+    } else {
+        flags |= EV_DELETE;
+    }
+
+    flags |= NGX_FLUSH_EVENT;
+    rc = ngx_kqueue_set_event(c->async, EVFILT_READ, flags);
+
+    c->async_fd = -1;
+
+    return rc;
+}
+#endif

 static ngx_int_t
 ngx_kqueue_process_events(ngx_cycle_t *cycle, ngx_msec_t timer,
diff --git a/src/event/modules/ngx_poll_module.c b/src/event/modules/ngx_poll_module.c
index c16f0242e..fab869445 100644
--- a/src/event/modules/ngx_poll_module.c
+++ b/src/event/modules/ngx_poll_module.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -42,7 +43,9 @@ static ngx_event_module_t  ngx_poll_module_ctx = {
         NULL,                              /* trigger a notify */
         ngx_poll_process_events,           /* process the events */
         ngx_poll_init,                     /* init the events */
-        ngx_poll_done                      /* done the events */
+        ngx_poll_done,                     /* done the events */
+        NULL,                              /* add an async conn */
+        NULL                               /* del an async conn */
     }

 };
diff --git a/src/event/modules/ngx_select_module.c b/src/event/modules/ngx_select_module.c
index b9fceb3b6..ba9ffcdd0 100644
--- a/src/event/modules/ngx_select_module.c
+++ b/src/event/modules/ngx_select_module.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -50,7 +51,9 @@ static ngx_event_module_t  ngx_select_module_ctx = {
         NULL,                              /* trigger a notify */
         ngx_select_process_events,         /* process the events */
         ngx_select_init,                   /* init the events */
-        ngx_select_done                    /* done the events */
+        ngx_select_done,                   /* done the events */
+        NULL,                              /* add an async conn */
+        NULL                               /* del an async conn */
     }

 };
diff --git a/src/event/modules/ngx_win32_select_module.c b/src/event/modules/ngx_win32_select_module.c
index 962514a36..f42095a27 100644
--- a/src/event/modules/ngx_win32_select_module.c
+++ b/src/event/modules/ngx_win32_select_module.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -52,7 +53,9 @@ static ngx_event_module_t  ngx_select_module_ctx = {
         NULL,                              /* trigger a notify */
         ngx_select_process_events,         /* process the events */
         ngx_select_init,                   /* init the events */
-        ngx_select_done                    /* done the events */
+        ngx_select_done,                   /* done the events */
+        NULL,                              /* add an async conn */
+        NULL                               /* del an async conn */
     }

 };
diff --git a/src/event/ngx_event.c b/src/event/ngx_event.c
index 47229b507..978f14523 100644
--- a/src/event/ngx_event.c
+++ b/src/event/ngx_event.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -78,6 +79,10 @@ ngx_atomic_t         *ngx_stat_waiting = &ngx_stat_waiting0;
 #endif


+ngx_atomic_t   ngx_ssl_active0 = 0;
+ngx_atomic_t  *ngx_ssl_active = &ngx_ssl_active0;
+
+

 static ngx_command_t  ngx_events_commands[] = {

@@ -171,7 +176,7 @@ static ngx_event_module_t  ngx_event_core_module_ctx = {
     ngx_event_core_create_conf,            /* create configuration */
     ngx_event_core_init_conf,              /* init configuration */

-    { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
+    { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
 };


@@ -616,6 +621,9 @@ ngx_event_process_init(ngx_cycle_t *cycle)
 {
     ngx_uint_t           m, i;
     ngx_event_t         *rev, *wev;
+#if (NGX_SSL)
+    ngx_event_t         *aev;
+#endif
     ngx_listening_t     *ls;
     ngx_connection_t    *c, *next, *old;
     ngx_core_conf_t     *ccf;
@@ -761,6 +769,20 @@ ngx_event_process_init(ngx_cycle_t *cycle)
         wev[i].closed = 1;
     }

+#if (NGX_SSL)
+    cycle->async_events = ngx_alloc(sizeof(ngx_event_t) * cycle->connection_n,
+                                    cycle->log);
+    if (cycle->async_events == NULL) {
+        return NGX_ERROR;
+    }
+
+    aev = cycle->async_events;
+    for (i = 0; i < cycle->connection_n; i++) {
+        aev[i].closed = 1;
+        aev[i].instance = 1;
+    }
+#endif
+
     i = cycle->connection_n;
     next = NULL;

@@ -771,6 +793,10 @@ ngx_event_process_init(ngx_cycle_t *cycle)
         c[i].read = &cycle->read_events[i];
         c[i].write = &cycle->write_events[i];
         c[i].fd = (ngx_socket_t) -1;
+#if (NGX_SSL)
+        c[i].async = &cycle->async_events[i];
+        c[i].async_fd = (ngx_socket_t) -1;
+#endif

         next = &c[i];
     } while (i);
diff --git a/src/event/ngx_event.h b/src/event/ngx_event.h
index 548c906e0..9b44b478c 100644
--- a/src/event/ngx_event.h
+++ b/src/event/ngx_event.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -32,6 +33,10 @@ struct ngx_event_s {

     unsigned         write:1;

+#if (NGX_SSL)
+    unsigned         async:1;
+#endif
+
     unsigned         accept:1;

     /* used to detect the stale events in kqueue and epoll */
@@ -101,6 +106,9 @@ struct ngx_event_s {
     int              available;

     ngx_event_handler_pt  handler;
+#if (NGX_SSL)
+    ngx_event_handler_pt  saved_handler;
+#endif


 #if (NGX_HAVE_IOCP)
@@ -177,9 +185,16 @@ typedef struct {

     ngx_int_t  (*process_events)(ngx_cycle_t *cycle, ngx_msec_t timer,
                                  ngx_uint_t flags);
+    ngx_int_t  (*process_callback)(ngx_cycle_t *cycle, ngx_msec_t timer,
+                                 ngx_uint_t flags);
+

     ngx_int_t  (*init)(ngx_cycle_t *cycle, ngx_msec_t timer);
     void       (*done)(ngx_cycle_t *cycle);
+
+    ngx_int_t  (*add_async_conn_to_q)(ngx_connection_t *c);
+    ngx_int_t  (*add_async_conn)(ngx_connection_t *c);
+    ngx_int_t  (*del_async_conn)(ngx_connection_t *c, ngx_uint_t flags);
 } ngx_event_actions_t;


@@ -398,12 +413,16 @@ extern ngx_uint_t            ngx_use_epoll_rdhup;


 #define ngx_process_events   ngx_event_actions.process_events
+#define ngx_process_callback   ngx_event_actions.process_callback
 #define ngx_done_events      ngx_event_actions.done

 #define ngx_add_event        ngx_event_actions.add
 #define ngx_del_event        ngx_event_actions.del
 #define ngx_add_conn         ngx_event_actions.add_conn
 #define ngx_del_conn         ngx_event_actions.del_conn
+#define ngx_add_async_conn_to_q     ngx_event_actions.add_async_conn_to_q
+#define ngx_add_async_conn   ngx_event_actions.add_async_conn
+#define ngx_del_async_conn   ngx_event_actions.del_async_conn

 #define ngx_notify           ngx_event_actions.notify

@@ -478,6 +497,9 @@ extern ngx_atomic_t  *ngx_stat_waiting;
 #endif


+extern ngx_atomic_t  *ngx_ssl_active;
+
+
 #define NGX_UPDATE_TIME         1
 #define NGX_POST_EVENTS         2

diff --git a/src/event/ngx_event_accept.c b/src/event/ngx_event_accept.c
index 27038799d..32d371d3d 100644
--- a/src/event/ngx_event_accept.c
+++ b/src/event/ngx_event_accept.c
@@ -2,12 +2,14 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


 #include <ngx_config.h>
 #include <ngx_core.h>
 #include <ngx_event.h>
+#include <ngx_ssl_engine.h>


 static ngx_int_t ngx_disable_accept_events(ngx_cycle_t *cycle, ngx_uint_t all);
@@ -247,6 +249,9 @@ ngx_event_accept(ngx_event_t *ev)

         rev->log = log;
         wev->log = log;
+#if (NGX_SSL)
+        c->async->log = log;
+#endif

         /*
          * TODO: MT: - ngx_atomic_fetch_add()
@@ -416,6 +421,15 @@ ngx_disable_accept_events(ngx_cycle_t *cycle, ngx_uint_t all)

 #endif

+#if (NGX_SSL)
+        if (c->asynch && ngx_del_async_conn) {
+            if (c->num_async_fds) {
+                ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                c->num_async_fds--;
+            }
+        }
+#endif
+
         if (ngx_del_event(c->read, NGX_READ_EVENT, NGX_DISABLE_EVENT)
             == NGX_ERROR)
         {
@@ -500,6 +514,14 @@ ngx_close_accepted_connection(ngx_connection_t *c)
 #if (NGX_STAT_STUB)
     (void) ngx_atomic_fetch_add(ngx_stat_active, -1);
 #endif
+
+#if (NGX_SSL)
+    if (c->ssl_enabled && ngx_use_ssl_engine
+        && ngx_ssl_engine_enable_heuristic_polling) {
+        (void) ngx_atomic_fetch_add(ngx_ssl_active, -1);
+        ngx_ssl_engine_heuristic_poll(c->log);
+    }
+#endif
 }


diff --git a/src/event/ngx_event_connect.c b/src/event/ngx_event_connect.c
index adbbde633..32b72e31b 100644
--- a/src/event/ngx_event_connect.c
+++ b/src/event/ngx_event_connect.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -188,6 +189,9 @@ ngx_event_connect_peer(ngx_peer_connection_t *pc)

     rev->log = pc->log;
     wev->log = pc->log;
+#if (NGX_SSL)
+    c->async->log = pc->log;
+#endif

     pc->connection = c;

diff --git a/src/event/ngx_event_openssl.c b/src/event/ngx_event_openssl.c
index 1e6fc9614..713e962f6 100644
--- a/src/event/ngx_event_openssl.c
+++ b/src/event/ngx_event_openssl.c
@@ -2,22 +2,19 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


 #include <ngx_config.h>
 #include <ngx_core.h>
 #include <ngx_event.h>
+#include <ngx_ssl_engine.h>


 #define NGX_SSL_PASSWORD_BUFFER_SIZE  4096


-typedef struct {
-    ngx_uint_t  engine;   /* unsigned  engine:1; */
-} ngx_openssl_conf_t;
-
-
 static X509 *ngx_ssl_load_certificate(ngx_pool_t *pool, char **err,
     ngx_str_t *cert, STACK_OF(X509) **chain);
 static EVP_PKEY *ngx_ssl_load_certificate_key(ngx_pool_t *pool, char **err,
@@ -87,45 +84,13 @@ static time_t ngx_ssl_parse_time(
 #endif
     ASN1_TIME *asn1time, ngx_log_t *log);

-static void *ngx_openssl_create_conf(ngx_cycle_t *cycle);
-static char *ngx_openssl_engine(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
-static void ngx_openssl_exit(ngx_cycle_t *cycle);
-
-
-static ngx_command_t  ngx_openssl_commands[] = {
-
-    { ngx_string("ssl_engine"),
-      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
-      ngx_openssl_engine,
-      0,
-      0,
-      NULL },
-
-      ngx_null_command
-};
+static void ngx_ssl_handshake_async_handler(ngx_event_t * aev);
+static void ngx_ssl_read_async_handler(ngx_event_t * aev);
+static void ngx_ssl_write_async_handler(ngx_event_t * aev);
+static void ngx_ssl_shutdown_async_handler(ngx_event_t *aev);
+int cpt_engine_callback(SSL *s, void* args);

-
-static ngx_core_module_t  ngx_openssl_module_ctx = {
-    ngx_string("openssl"),
-    ngx_openssl_create_conf,
-    NULL
-};
-
-
-ngx_module_t  ngx_openssl_module = {
-    NGX_MODULE_V1,
-    &ngx_openssl_module_ctx,               /* module context */
-    ngx_openssl_commands,                  /* module directives */
-    NGX_CORE_MODULE,                       /* module type */
-    NULL,                                  /* init master */
-    NULL,                                  /* init module */
-    NULL,                                  /* init process */
-    NULL,                                  /* init thread */
-    NULL,                                  /* exit thread */
-    NULL,                                  /* exit process */
-    ngx_openssl_exit,                      /* exit master */
-    NGX_MODULE_V1_PADDING
-};
+#define NGX_ASYNC_EVENT_TIMEOUT 10000


 int  ngx_ssl_connection_index;
@@ -139,22 +104,74 @@ int  ngx_ssl_certificate_name_index;
 int  ngx_ssl_stapling_index;


+extern ngx_uint_t ngx_no_ssl_init;
+
+
+static void
+ngx_ssl_empty_handler(ngx_event_t *ev)
+{
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ev->log, 0, "ssl empty handler");
+
+    if(ev->timedout &&
+       ev->saved_handler &&
+       ev->saved_handler != ngx_ssl_empty_handler ) {
+        ev->saved_handler(ev);
+    }
+
+    return;
+}
+
+
 ngx_int_t
-ngx_ssl_init(ngx_log_t *log)
+ngx_ssl_conf_load(ngx_log_t *log)
 {
-#if OPENSSL_VERSION_NUMBER >= 0x10100003L
+    char* ossl_conf;
+    ossl_conf = getenv("OPENSSL_CONF_MULTI");
+    if (CONF_modules_load_file(ossl_conf, NULL, 0) <=0 ) {
+        ngx_ssl_error(NGX_LOG_ALERT, log, 0, "Error loading openssl conf file\n");
+        return NGX_ERROR;
+    }

-    if (OPENSSL_init_ssl(OPENSSL_INIT_LOAD_CONFIG, NULL) == 0) {
-        ngx_ssl_error(NGX_LOG_ALERT, log, 0, "OPENSSL_init_ssl() failed");
+    ENGINE* engine = ENGINE_by_id("dpdk_engine");
+
+    if (engine == NULL) {
+        ngx_ssl_error(NGX_LOG_ALERT, log, 0,
+                      "ENGINE_by_id failed");
         return NGX_ERROR;
     }

-    /*
-     * OPENSSL_init_ssl() may leave errors in the error queue
-     * while returning success
-     */
+    if (ENGINE_set_default_RSA(engine) == 0 || ENGINE_set_default_EC(engine) == 0) {
+        ngx_ssl_error(NGX_LOG_ALERT, log, 0,
+                      "ENGINE_set_default(ENGINE_METHOD_ALL) failed");

-    ERR_clear_error();
+        ENGINE_free(engine);
+
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+ngx_int_t
+ngx_ssl_init(ngx_log_t *log)
+{
+    if (!ngx_no_ssl_init) {
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100003L
+        if (OPENSSL_init_ssl(OPENSSL_INIT_LOAD_CONFIG, NULL) == 0) {
+            ngx_ssl_error(NGX_LOG_ALERT, log, 0, "OPENSSL_init_ssl() failed");
+            return NGX_ERROR;
+        }
+
+        /*
+         * OPENSSL_init_ssl() may leave errors in the error queue
+         * while returning success
+         */
+
+        ERR_clear_error();
+
+        ENGINE_load_builtin_engines();
+        ENGINE_load_dynamic();

 #else

@@ -167,6 +184,8 @@ ngx_ssl_init(ngx_log_t *log)

 #endif

+    }
+
 #ifndef SSL_OP_NO_COMPRESSION
     {
     /*
@@ -387,6 +406,10 @@ ngx_ssl_create(ngx_ssl_t *ssl, ngx_uint_t protocols, void *data)
     SSL_CTX_set_mode(ssl->ctx, SSL_MODE_NO_AUTO_CHAIN);
 #endif

+    if(ssl->asynch) {
+        SSL_CTX_set_mode(ssl->ctx, SSL_MODE_ASYNC);
+    }
+
     SSL_CTX_set_read_ahead(ssl->ctx, 1);

     SSL_CTX_set_info_callback(ssl->ctx, ngx_ssl_info_callback);
@@ -427,6 +450,8 @@ ngx_ssl_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,
     EVP_PKEY        *pkey;
     STACK_OF(X509)  *chain;

+    ngx_ssl_engine_unload_check(cf->cycle);
+
     x509 = ngx_ssl_load_certificate(cf->pool, &err, cert, &chain);
     if (x509 == NULL) {
         if (err != NULL) {
@@ -466,6 +491,7 @@ ngx_ssl_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,
     }

     if (SSL_CTX_set_ex_data(ssl->ctx, ngx_ssl_certificate_index, x509) == 0) {
+
         ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
                       "SSL_CTX_set_ex_data() failed");
         X509_free(x509);
@@ -1616,6 +1642,22 @@ ngx_ssl_new_client_session(ngx_ssl_conn_t *ssl_conn, ngx_ssl_session_t *sess)
     return 0;
 }

+int cpt_engine_callback(SSL *s, void* args) {
+	ngx_connection_t  *c;
+    ngx_event_t       *aev;
+
+    c = (ngx_connection_t *) args;
+    aev = c->async;
+
+    if (aev->active) {
+        //aev->ready = 1;
+        //aev->handler(aev);
+	//fprintf(stderr, "\nConnection Address %p inserted to Queue\n", c);
+    	ngx_add_async_conn_to_q(c);
+    }
+
+    return 1;
+}

 ngx_int_t
 ngx_ssl_create_connection(ngx_ssl_t *ssl, ngx_connection_t *c, ngx_uint_t flags)
@@ -1632,6 +1674,24 @@ ngx_ssl_create_connection(ngx_ssl_t *ssl, ngx_connection_t *c, ngx_uint_t flags)

     sc->session_ctx = ssl->ctx;

+    if (ssl->max_pipelines > 0) {
+        SSL_CTX_set_max_pipelines(ssl->ctx, ssl->max_pipelines);
+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ssl->log, 0,
+                "Set max_pipelines = %d", ssl->max_pipelines);
+    }
+
+    if (ssl->split_send_fragment > 0) {
+        SSL_CTX_set_split_send_fragment(ssl->ctx, ssl->split_send_fragment);
+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ssl->log, 0,
+                "Set split_send_fragment = %d", ssl->split_send_fragment);
+    }
+
+    if (ssl->max_send_fragment > 0) {
+        SSL_CTX_set_max_send_fragment(ssl->ctx, ssl->max_send_fragment);
+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ssl->log, 0,
+                "Set max_send_fragment = %d", ssl->max_send_fragment);
+    }
+
 #ifdef SSL_READ_EARLY_DATA_SUCCESS
     if (SSL_CTX_get_max_early_data(ssl->ctx)) {
         sc->try_early_data = 1;
@@ -1668,6 +1728,15 @@ ngx_ssl_create_connection(ngx_ssl_t *ssl, ngx_connection_t *c, ngx_uint_t flags)

     c->ssl = sc;

+    if(ssl->asynch && !c->asynch) {
+        c->asynch = ssl->asynch;
+    } else if (c->asynch) {
+        SSL_set_mode(sc->connection,SSL_MODE_ASYNC);
+    }
+
+    SSL_set_async_callback(sc->connection, cpt_engine_callback);
+	SSL_set_async_callback_arg(sc->connection, (void*)c);
+
     return NGX_OK;
 }

@@ -1710,6 +1779,89 @@ ngx_ssl_set_session(ngx_connection_t *c, ngx_ssl_session_t *session)
     return NGX_OK;
 }

+ngx_int_t
+ngx_ssl_async_process_fds(ngx_connection_t *c)
+{
+    OSSL_ASYNC_FD *add_fds = NULL;
+    OSSL_ASYNC_FD *del_fds = NULL;
+    size_t        num_add_fds = 0;
+    size_t        num_del_fds = 0;
+    //unsigned      loop = 0;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                   "ngx_ssl_async_process_fds called");
+
+    if (!ngx_del_async_conn || !ngx_add_async_conn) {
+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0,
+                      "Async notifications not supported");
+        return 0;
+    }
+
+    SSL_get_changed_async_fds(c->ssl->connection, NULL, &num_add_fds,
+                              NULL, &num_del_fds);
+#if 0
+    if (num_add_fds) {
+        add_fds = ngx_alloc(num_add_fds * sizeof(OSSL_ASYNC_FD), c->log);
+        if (add_fds == NULL) {
+            ngx_ssl_error(NGX_LOG_ALERT, c->log, 0,
+                          "Memory Allocation Error");
+            return 0;
+        }
+    }
+
+    if (num_del_fds) {
+        del_fds = ngx_alloc(num_del_fds * sizeof(OSSL_ASYNC_FD), c->log);
+        if (del_fds == NULL) {
+            ngx_ssl_error(NGX_LOG_ALERT, c->log, 0,
+                          "Memory Allocation Error");
+            if (add_fds)
+                ngx_free(add_fds);
+            return 0;
+        }
+    }
+
+    SSL_get_changed_async_fds(c->ssl->connection, add_fds, &num_add_fds,
+                              del_fds, &num_del_fds);
+#endif
+    if (num_del_fds) {
+        c->async_fd = -1;
+        c->async->active = 0;
+        /*
+        for (loop = 0; loop < num_del_fds; loop++) {
+            //c->async_fd = del_fds[loop];
+            if (c->num_async_fds) {
+                ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0, "%s: deleting fd = %d", __func__, c->async_fd);
+                //ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                c->num_async_fds--;
+            }
+        }
+        */
+    }
+    if (num_add_fds) {
+        c->async->active = 1;
+        /*
+        for (loop = 0; loop < num_add_fds; loop++) {
+            if (c->num_async_fds == 0) {
+                c->num_async_fds++;
+                //c->async_fd = add_fds[loop];
+                ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0, "%s: adding fd = %d", __func__, c->async_fd);
+                //ngx_add_async_conn(c);
+            }
+        }
+        */
+    }
+
+    if (add_fds)
+        ngx_free(add_fds);
+    if (del_fds)
+        ngx_free(del_fds);
+
+    if (ngx_ssl_engine_enable_heuristic_polling) {
+        ngx_ssl_engine_heuristic_poll(c->log);
+    }
+
+    return 1;
+}

 ngx_int_t
 ngx_ssl_handshake(ngx_connection_t *c)
@@ -1718,6 +1870,10 @@ ngx_ssl_handshake(ngx_connection_t *c)
     ngx_err_t  err;
     ngx_int_t  rc;

+    if (c->asynch && !c->async->handler) {
+        c->async->handler = ngx_ssl_empty_handler;
+    }
+
 #ifdef SSL_READ_EARLY_DATA_SUCCESS
     if (c->ssl->try_early_data) {
         return ngx_ssl_try_early_data(c);
@@ -1736,6 +1892,10 @@ ngx_ssl_handshake(ngx_connection_t *c)

     if (n == 1) {

+        if(c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
+
         if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
             return NGX_ERROR;
         }
@@ -1788,6 +1948,9 @@ ngx_ssl_handshake(ngx_connection_t *c)
         if (rc == NGX_AGAIN) {
             c->read->handler = ngx_ssl_handshake_handler;
             c->write->handler = ngx_ssl_handshake_handler;
+            if (c->asynch) {
+                c->async->handler = ngx_ssl_handshake_async_handler;
+            }
             return NGX_AGAIN;
         }

@@ -1801,6 +1964,9 @@ ngx_ssl_handshake(ngx_connection_t *c)
     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, "SSL_get_error: %d", sslerr);

     if (sslerr == SSL_ERROR_WANT_READ) {
+        if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
         c->read->ready = 0;
         c->read->handler = ngx_ssl_handshake_handler;
         c->write->handler = ngx_ssl_handshake_handler;
@@ -1817,6 +1983,9 @@ ngx_ssl_handshake(ngx_connection_t *c)
     }

     if (sslerr == SSL_ERROR_WANT_WRITE) {
+        if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
         c->write->ready = 0;
         c->read->handler = ngx_ssl_handshake_handler;
         c->write->handler = ngx_ssl_handshake_handler;
@@ -1832,6 +2001,32 @@ ngx_ssl_handshake(ngx_connection_t *c)
         return NGX_AGAIN;
     }

+    if (c->asynch && sslerr == SSL_ERROR_WANT_ASYNC)
+    {
+        c->async->ready = 0;
+        c->async->handler = ngx_ssl_handshake_async_handler;
+        if (c->read->handler != ngx_ssl_empty_handler) {
+            c->read->saved_handler = c->read->handler;
+            c->read->handler = ngx_ssl_empty_handler;
+        }
+
+        if (c->write->handler != ngx_ssl_empty_handler) {
+            c->write->saved_handler = c->write->handler;
+            c->write->handler = ngx_ssl_empty_handler;
+        }
+
+        ngx_add_timer(c->async, NGX_ASYNC_EVENT_TIMEOUT);
+
+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                       "SSL ASYNC WANT received: \"%s\"", __func__);
+
+        if (ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
+
+        return NGX_AGAIN;
+    }
+
     err = (sslerr == SSL_ERROR_SYSCALL) ? ngx_errno : 0;

     c->ssl->no_wait_shutdown = 1;
@@ -1886,6 +2081,9 @@ ngx_ssl_try_early_data(ngx_connection_t *c)
     }

     if (n == SSL_READ_EARLY_DATA_SUCCESS) {
+        if(c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }

         if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
             return NGX_ERROR;
@@ -1933,6 +2131,9 @@ ngx_ssl_try_early_data(ngx_connection_t *c)
         if (rc == NGX_AGAIN) {
             c->read->handler = ngx_ssl_handshake_handler;
             c->write->handler = ngx_ssl_handshake_handler;
+            if (c->asynch) {
+                c->async->handler = ngx_ssl_handshake_async_handler;
+            }
             return NGX_AGAIN;
         }

@@ -1948,6 +2149,9 @@ ngx_ssl_try_early_data(ngx_connection_t *c)
     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, "SSL_get_error: %d", sslerr);

     if (sslerr == SSL_ERROR_WANT_READ) {
+        if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
         c->read->ready = 0;
         c->read->handler = ngx_ssl_handshake_handler;
         c->write->handler = ngx_ssl_handshake_handler;
@@ -1964,6 +2168,9 @@ ngx_ssl_try_early_data(ngx_connection_t *c)
     }

     if (sslerr == SSL_ERROR_WANT_WRITE) {
+        if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
         c->write->ready = 0;
         c->read->handler = ngx_ssl_handshake_handler;
         c->write->handler = ngx_ssl_handshake_handler;
@@ -1976,6 +2183,32 @@ ngx_ssl_try_early_data(ngx_connection_t *c)
             return NGX_ERROR;
         }

+        return NGX_AGAIN;
+    }
+    if (c->asynch && sslerr == SSL_ERROR_WANT_ASYNC)
+    {
+        c->async->ready = 0;
+        c->async->handler = ngx_ssl_handshake_async_handler;
+        if (c->read->handler != ngx_ssl_empty_handler) {
+            c->read->saved_handler = c->read->handler;
+            c->read->handler = ngx_ssl_empty_handler;
+        }
+
+        if (c->write->handler != ngx_ssl_empty_handler) {
+            c->write->saved_handler = c->write->handler;
+            c->write->handler = ngx_ssl_empty_handler;
+        }
+
+        ngx_add_timer(c->async, NGX_ASYNC_EVENT_TIMEOUT);
+
+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                       "SSL ASYNC WANT received: \"%s\"", __func__);
+
+        if (ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
+
+
         return NGX_AGAIN;
     }

@@ -2058,6 +2291,41 @@ ngx_ssl_handshake_log(ngx_connection_t *c)
 #endif


+static void
+ngx_ssl_handshake_async_handler(ngx_event_t *aev)
+{
+    ngx_connection_t  *c;
+
+    c = aev->data;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                   "SSL handshake async handler");
+
+    if (!aev->ready && aev->timedout) {
+        c->ssl->handler(c);
+        return;
+    }
+
+    aev->ready = 0;
+    aev->handler = ngx_ssl_empty_handler;
+    if (c->read->saved_handler != ngx_ssl_empty_handler) {
+        c->read->handler = c->read->saved_handler;
+        c->read->saved_handler = ngx_ssl_empty_handler;
+    }
+
+    if (c->write->saved_handler != ngx_ssl_empty_handler) {
+        c->write->handler = c->write->saved_handler;
+        c->write->saved_handler = ngx_ssl_empty_handler;
+    }
+
+    if (ngx_ssl_handshake(c) == NGX_AGAIN) {
+        return;
+    }
+
+    c->ssl->handler(c);
+}
+
+
 static void
 ngx_ssl_handshake_handler(ngx_event_t *ev)
 {
@@ -2407,6 +2675,23 @@ ngx_ssl_handle_recv(ngx_connection_t *c, int n)

         ngx_log_error(NGX_LOG_NOTICE, c->log, 0, "SSL renegotiation disabled");

+        if (c->asynch \
+            && SSL_get_error(c->ssl->connection, n) == SSL_ERROR_WANT_ASYNC) {
+            c->async->ready = 0;
+            c->async->handler = ngx_ssl_read_async_handler;
+            if (c->read->handler != ngx_ssl_empty_handler) {
+                c->read->saved_handler = c->read->handler;
+                c->read->handler = ngx_ssl_empty_handler;
+            }
+            ngx_add_timer(c->async, NGX_ASYNC_EVENT_TIMEOUT);
+
+            if (ngx_ssl_async_process_fds(c) == 0) {
+                return NGX_ERROR;
+            }
+
+            return NGX_AGAIN;
+        }
+
         while (ERR_peek_error()) {
             ngx_ssl_error(NGX_LOG_DEBUG, c->log, 0,
                           "ignoring stale global SSL error");
@@ -2424,6 +2709,10 @@ ngx_ssl_handle_recv(ngx_connection_t *c, int n)

     if (n > 0) {

+        if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
+
         if (c->ssl->saved_write_handler) {

             c->write->handler = c->ssl->saved_write_handler;
@@ -2441,13 +2730,16 @@ ngx_ssl_handle_recv(ngx_connection_t *c, int n)
     }

     sslerr = SSL_get_error(c->ssl->connection, n);
-
     err = (sslerr == SSL_ERROR_SYSCALL) ? ngx_errno : 0;

     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, "SSL_get_error: %d", sslerr);

     if (sslerr == SSL_ERROR_WANT_READ) {

+        if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
+
         if (c->ssl->saved_write_handler) {

             c->write->handler = c->ssl->saved_write_handler;
@@ -2467,8 +2759,12 @@ ngx_ssl_handle_recv(ngx_connection_t *c, int n)

     if (sslerr == SSL_ERROR_WANT_WRITE) {

-        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
-                       "SSL_read: want write");
+        ngx_log_error(NGX_LOG_INFO, c->log, 0,
+                      "peer started SSL renegotiation");
+
+        if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }

         c->write->ready = 0;

@@ -2488,6 +2784,26 @@ ngx_ssl_handle_recv(ngx_connection_t *c, int n)
         return NGX_AGAIN;
     }

+    if (c->asynch && sslerr == SSL_ERROR_WANT_ASYNC) {
+        c->async->ready = 0;
+        c->async->handler = ngx_ssl_read_async_handler;
+        if (c->read->handler != ngx_ssl_empty_handler) {
+            c->read->saved_handler = c->read->handler;
+            c->read->handler = ngx_ssl_empty_handler;
+        }
+
+        ngx_add_timer(c->async, NGX_ASYNC_EVENT_TIMEOUT);
+
+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                       "SSL ASYNC WANT received: \"%s\"", __func__);
+
+        if (ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
+
+        return NGX_AGAIN;
+    }
+
     c->ssl->no_wait_shutdown = 1;
     c->ssl->no_send_shutdown = 1;

@@ -2503,6 +2819,32 @@ ngx_ssl_handle_recv(ngx_connection_t *c, int n)
 }


+static void
+ngx_ssl_read_async_handler(ngx_event_t *aev)
+{
+    ngx_connection_t  *c;
+
+    c = aev->data;
+
+    if (c->destroyed) {
+        return;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                   "SSL read async handler");
+
+    aev->ready = 0;
+    aev->handler = ngx_ssl_empty_handler;
+    if (c->read->saved_handler != ngx_ssl_empty_handler) {
+        c->read->handler = c->read->saved_handler;
+        c->read->saved_handler = ngx_ssl_empty_handler;
+    }
+
+    c->read->ready = 1;
+    c->read->handler(c->read);
+}
+
+
 static void
 ngx_ssl_write_handler(ngx_event_t *wev)
 {
@@ -2734,6 +3076,10 @@ ngx_ssl_write(ngx_connection_t *c, u_char *data, size_t size)

     if (n > 0) {

+        if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
+
         if (c->ssl->saved_read_handler) {

             c->read->handler = c->ssl->saved_read_handler;
@@ -2772,6 +3118,10 @@ ngx_ssl_write(ngx_connection_t *c, u_char *data, size_t size)

     if (sslerr == SSL_ERROR_WANT_WRITE) {

+        if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
+
         if (c->ssl->saved_read_handler) {

             c->read->handler = c->ssl->saved_read_handler;
@@ -2791,9 +3141,12 @@ ngx_ssl_write(ngx_connection_t *c, u_char *data, size_t size)

     if (sslerr == SSL_ERROR_WANT_READ) {

-        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
-                       "SSL_write: want read");
+        ngx_log_error(NGX_LOG_INFO, c->log, 0,
+                      "peer started SSL renegotiation");

+        if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
         c->read->ready = 0;

         if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
@@ -2813,6 +3166,26 @@ ngx_ssl_write(ngx_connection_t *c, u_char *data, size_t size)
         return NGX_AGAIN;
     }

+    if(c->asynch && sslerr == SSL_ERROR_WANT_ASYNC) {
+        c->async->ready = 0;
+        c->async->handler = ngx_ssl_write_async_handler;
+        if (c->read->handler != ngx_ssl_empty_handler) {
+            c->read->saved_handler = c->read->handler;
+            c->read->handler = ngx_ssl_empty_handler;
+        }
+
+        ngx_add_timer(c->async, NGX_ASYNC_EVENT_TIMEOUT);
+
+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                       "SSL ASYNC WANT received: \"%s\"", __func__);
+
+        if (ngx_ssl_async_process_fds(c) == 0) {
+            return NGX_ERROR;
+        }
+
+        return NGX_AGAIN;
+    }
+
     c->ssl->no_wait_shutdown = 1;
     c->ssl->no_send_shutdown = 1;
     c->write->error = 1;
@@ -2823,6 +3196,31 @@ ngx_ssl_write(ngx_connection_t *c, u_char *data, size_t size)
 }


+static void
+ngx_ssl_write_async_handler(ngx_event_t *aev)
+{
+    ngx_connection_t  *c;
+
+    c = aev->data;
+
+    if (c->destroyed) {
+        return;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                   "SSL write async handler");
+
+    aev->ready = 0;
+    aev->handler = ngx_ssl_empty_handler;
+    if (c->read->saved_handler != ngx_ssl_empty_handler) {
+        c->read->handler = c->read->saved_handler;
+        c->read->saved_handler = ngx_ssl_empty_handler;
+    }
+
+    c->write->handler(c->write);
+}
+
+
 #ifdef SSL_READ_EARLY_DATA_SUCCESS

 static ssize_t
@@ -3153,6 +3551,10 @@ ngx_ssl_shutdown(ngx_connection_t *c)

     ngx_ssl_ocsp_cleanup(c);

+    if(!c->ssl) {
+        return NGX_OK;
+    }
+
     if (SSL_in_init(c->ssl->connection)) {
         /*
          * OpenSSL 1.0.2f complains if SSL_shutdown() is called during
@@ -3160,6 +3562,34 @@ ngx_ssl_shutdown(ngx_connection_t *c)
          * Avoid calling SSL_shutdown() if handshake wasn't completed.
          */

+        if(c->asynch) {
+            /* Check if there is inflight request.
+             * Wait till async job becomes finished.
+             */
+            if (SSL_want_async(c->ssl->connection)) {
+                ngx_ssl_async_process_fds(c);
+                if(!c->async->timer_set)
+                    ngx_add_timer(c->async, NGX_ASYNC_EVENT_TIMEOUT);
+                return NGX_AGAIN;
+            }
+
+            /* Ignore errors from ngx_ssl_async_process_fds as
+               we want to carry on and close the SSL connection
+               anyway. */
+            ngx_ssl_async_process_fds(c);
+            if (ngx_del_async_conn) {
+                if (c->num_async_fds) {
+                    //ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                    c->async_fd = -1;
+                    c->async->active = 0;
+                    c->num_async_fds--;
+                }
+            }
+            if(ngx_del_conn && c->read->active) {
+                ngx_del_conn(c, NGX_DISABLE_EVENT);
+            }
+        }
+
         goto done;
     }

@@ -3202,10 +3632,45 @@ ngx_ssl_shutdown(ngx_connection_t *c)
         ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, "SSL_shutdown: %d", n);

         if (n == 1) {
+            if(c->asynch) {
+                /* Ignore errors from ngx_ssl_async_process_fds as
+                   we want to carry on and close the SSL connection
+                   anyway. */
+                ngx_ssl_async_process_fds(c);
+                if (ngx_del_async_conn) {
+                    if (c->num_async_fds) {
+                        //ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                        c->async_fd = -1;
+                        c->async->active = 0;
+                        c->num_async_fds--;
+                    }
+                }
+                if(ngx_del_conn && c->read->active) {
+                    ngx_del_conn(c, NGX_DISABLE_EVENT);
+                }
+            }
+
             goto done;
         }

         if (n == 0 && tries-- > 1) {
+            if(c->asynch) {
+                /* Ignore errors from ngx_ssl_async_process_fds as
+                   we want to carry on and close the SSL connection
+                   anyway. */
+                ngx_ssl_async_process_fds(c);
+                if (ngx_del_async_conn) {
+                    if (c->num_async_fds) {
+                        //ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                        c->async_fd = -1;
+                        c->async->active = 0;
+                        c->num_async_fds--;
+                    }
+                }
+                if(ngx_del_conn && c->read->active) {
+                    ngx_del_conn(c, NGX_DISABLE_EVENT);
+                }
+            }
             continue;
         }

@@ -3215,10 +3680,52 @@ ngx_ssl_shutdown(ngx_connection_t *c)

         ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
                        "SSL_get_error: %d", sslerr);
+        if(c->asynch && n == -1) {
+            if (sslerr == SSL_ERROR_WANT_ASYNC) {
+                c->async->ready = 0;
+                c->async->handler = ngx_ssl_shutdown_async_handler;
+                c->read->saved_handler = ngx_ssl_shutdown_handler;
+                if (c->read->handler != ngx_ssl_empty_handler)
+                    c->read->handler = ngx_ssl_empty_handler;
+                c->write->handler = ngx_ssl_shutdown_handler;
+
+                ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                           "SSL ASYNC WANT received: \"%s\"", __func__);
+
+                ngx_add_timer(c->async, NGX_ASYNC_EVENT_TIMEOUT);
+                /* Ignore errors from ngx_ssl_async_process_fds as
+                   we want to carry on anyway */
+                ngx_ssl_async_process_fds(c);
+                return NGX_AGAIN;
+            }
+
+            /* Ignore errors from ngx_ssl_async_process_fds as
+               we want to carry on and close the SSL connection
+               anyway. */
+            ngx_ssl_async_process_fds(c);
+            if (ngx_del_async_conn) {
+                if (c->num_async_fds) {
+                    //ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                    c->async_fd = -1;
+                    c->async->active = 0;
+                    c->num_async_fds--;
+                }
+            }
+            if(ngx_del_conn && c->read->active) {
+                ngx_del_conn(c, NGX_DISABLE_EVENT);
+            }
+        }

         if (sslerr == SSL_ERROR_WANT_READ || sslerr == SSL_ERROR_WANT_WRITE) {
             c->read->handler = ngx_ssl_shutdown_handler;
             c->write->handler = ngx_ssl_shutdown_handler;
+            if (c->asynch && ngx_ssl_async_process_fds(c) == 0) {
+                goto failed;
+            }
+
+            //Work around: Readd write event on shutdown;
+            c->write->ready = 0;
+            c->write->active = 0;

             if (sslerr == SSL_ERROR_WANT_READ) {
                 c->read->ready = 0;
@@ -3237,10 +3744,32 @@ ngx_ssl_shutdown(ngx_connection_t *c)

             ngx_add_timer(c->read, 3000);

+            if (sslerr == SSL_ERROR_WANT_WRITE) {
+                ngx_add_timer(c->write, 10000);
+            }
+
             return NGX_AGAIN;
         }

         if (sslerr == SSL_ERROR_ZERO_RETURN || ERR_peek_error() == 0) {
+            if(c->asynch) {
+                /* Ignore errors from ngx_ssl_async_process_fds as
+                   we want to carry on and close the SSL connection
+                   anyway. */
+                ngx_ssl_async_process_fds(c);
+                if (ngx_del_async_conn) {
+                    if (c->num_async_fds) {
+                        //ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                        c->async_fd = -1;
+                        c->async->active = 0;
+                        c->num_async_fds--;
+                    }
+                }
+                if(ngx_del_conn && c->read->active) {
+                    ngx_del_conn(c, NGX_DISABLE_EVENT);
+                }
+            }
+
             goto done;
         }

@@ -3271,6 +3800,37 @@ done:
 }


+static void
+ngx_ssl_shutdown_async_handler(ngx_event_t *aev)
+{
+    ngx_connection_t           *c;
+    ngx_connection_handler_pt   handler;
+
+    c = aev->data;
+    handler = c->ssl->handler;
+
+    if (!aev->ready && aev->timedout) {
+        c->timedout = 1;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, aev->log, 0,
+                   "SSL shutdown async handler");
+
+    aev->ready = 0;
+    aev->handler = ngx_ssl_empty_handler;
+    if (c->read->saved_handler != ngx_ssl_empty_handler) {
+        c->read->handler = c->read->saved_handler;
+        c->read->saved_handler = ngx_ssl_empty_handler;
+    }
+
+    if (ngx_ssl_shutdown(c) == NGX_AGAIN) {
+        return;
+    }
+
+    handler(c);
+}
+
+
 static void
 ngx_ssl_shutdown_handler(ngx_event_t *ev)
 {
@@ -5630,85 +6190,3 @@ ngx_ssl_parse_time(

     return time;
 }
-
-
-static void *
-ngx_openssl_create_conf(ngx_cycle_t *cycle)
-{
-    ngx_openssl_conf_t  *oscf;
-
-    oscf = ngx_pcalloc(cycle->pool, sizeof(ngx_openssl_conf_t));
-    if (oscf == NULL) {
-        return NULL;
-    }
-
-    /*
-     * set by ngx_pcalloc():
-     *
-     *     oscf->engine = 0;
-     */
-
-    return oscf;
-}
-
-
-static char *
-ngx_openssl_engine(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
-{
-#ifndef OPENSSL_NO_ENGINE
-
-    ngx_openssl_conf_t *oscf = conf;
-
-    ENGINE     *engine;
-    ngx_str_t  *value;
-
-    if (oscf->engine) {
-        return "is duplicate";
-    }
-
-    oscf->engine = 1;
-
-    value = cf->args->elts;
-
-    engine = ENGINE_by_id((char *) value[1].data);
-
-    if (engine == NULL) {
-        ngx_ssl_error(NGX_LOG_EMERG, cf->log, 0,
-                      "ENGINE_by_id(\"%V\") failed", &value[1]);
-        return NGX_CONF_ERROR;
-    }
-
-    if (ENGINE_set_default(engine, ENGINE_METHOD_ALL) == 0) {
-        ngx_ssl_error(NGX_LOG_EMERG, cf->log, 0,
-                      "ENGINE_set_default(\"%V\", ENGINE_METHOD_ALL) failed",
-                      &value[1]);
-
-        ENGINE_free(engine);
-
-        return NGX_CONF_ERROR;
-    }
-
-    ENGINE_free(engine);
-
-    return NGX_CONF_OK;
-
-#else
-
-    return "is not supported";
-
-#endif
-}
-
-
-static void
-ngx_openssl_exit(ngx_cycle_t *cycle)
-{
-#if OPENSSL_VERSION_NUMBER < 0x10100003L
-
-    EVP_cleanup();
-#ifndef OPENSSL_NO_ENGINE
-    ENGINE_cleanup();
-#endif
-
-#endif
-}
diff --git a/src/event/ngx_event_openssl.h b/src/event/ngx_event_openssl.h
index c9e86d9c0..ffc7bd003 100644
--- a/src/event/ngx_event_openssl.h
+++ b/src/event/ngx_event_openssl.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -82,6 +83,10 @@ struct ngx_ssl_s {
     SSL_CTX                    *ctx;
     ngx_log_t                  *log;
     size_t                      buffer_size;
+    ngx_flag_t                  asynch;
+    size_t                      max_pipelines;
+    size_t                      split_send_fragment;
+    size_t                      max_send_fragment;
 };


@@ -176,9 +181,10 @@ typedef struct {
 #define NGX_SSL_BUFFER   1
 #define NGX_SSL_CLIENT   2

-#define NGX_SSL_BUFSIZE  16384
+#define NGX_SSL_BUFSIZE  (16384*8)


+ngx_int_t ngx_ssl_conf_load(ngx_log_t *log);
 ngx_int_t ngx_ssl_init(ngx_log_t *log);
 ngx_int_t ngx_ssl_create(ngx_ssl_t *ssl, ngx_uint_t protocols, void *data);

@@ -249,6 +255,7 @@ ngx_ssl_session_t *ngx_ssl_get0_session(ngx_connection_t *c);

 ngx_int_t ngx_ssl_check_host(ngx_connection_t *c, ngx_str_t *name);

+#define ngx_ssl_waiting_for_async(c) SSL_waiting_for_async(c->ssl->connection)

 ngx_int_t ngx_ssl_get_protocol(ngx_connection_t *c, ngx_pool_t *pool,
     ngx_str_t *s);
@@ -309,7 +316,7 @@ ngx_int_t ngx_ssl_shutdown(ngx_connection_t *c);
 void ngx_cdecl ngx_ssl_error(ngx_uint_t level, ngx_log_t *log, ngx_err_t err,
     char *fmt, ...);
 void ngx_ssl_cleanup_ctx(void *data);
-
+ngx_int_t ngx_ssl_async_process_fds(ngx_connection_t *c) ;

 extern int  ngx_ssl_connection_index;
 extern int  ngx_ssl_server_conf_index;
diff --git a/src/event/ngx_event_timer.c b/src/event/ngx_event_timer.c
index 35052bc29..fba78dd77 100644
--- a/src/event/ngx_event_timer.c
+++ b/src/event/ngx_event_timer.c
@@ -92,6 +92,8 @@ ngx_event_expire_timers(void)
         ev->timedout = 1;

         ev->handler(ev);
+
+    	ngx_process_callback(NULL, 0, 0);
     }
 }

diff --git a/src/http/modules/ngx_http_grpc_module.c b/src/http/modules/ngx_http_grpc_module.c
index 864fc4fda..c44fbfe39 100644
--- a/src/http/modules/ngx_http_grpc_module.c
+++ b/src/http/modules/ngx_http_grpc_module.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Maxim Dounin
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -357,6 +358,12 @@ static ngx_command_t  ngx_http_grpc_commands[] = {
       &ngx_http_upstream_ignore_headers_masks },

 #if (NGX_HTTP_SSL)
+    { ngx_string("grpc_ssl_asynch"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_grpc_loc_conf_t, upstream.ssl_asynch),
+      NULL },

     { ngx_string("grpc_ssl_session_reuse"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
@@ -4370,6 +4377,7 @@ ngx_http_grpc_create_loc_conf(ngx_conf_t *cf)
     conf->upstream.intercept_errors = NGX_CONF_UNSET;

 #if (NGX_HTTP_SSL)
+    conf->upstream.ssl_asynch = NGX_CONF_UNSET;
     conf->upstream.ssl_session_reuse = NGX_CONF_UNSET;
     conf->upstream.ssl_name = NGX_CONF_UNSET_PTR;
     conf->upstream.ssl_server_name = NGX_CONF_UNSET;
@@ -4458,6 +4466,8 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
                               prev->upstream.intercept_errors, 0);

 #if (NGX_HTTP_SSL)
+    ngx_conf_merge_value(conf->upstream.ssl_asynch,
+                              prev->upstream.ssl_asynch, 0);

     ngx_conf_merge_value(conf->upstream.ssl_session_reuse,
                               prev->upstream.ssl_session_reuse, 1);
@@ -4491,6 +4501,13 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_ptr_value(conf->ssl_conf_commands,
                               prev->ssl_conf_commands, NULL);

+    ngx_conf_merge_value(conf->upstream.ssl_asynch,
+                              prev->upstream.ssl_asynch, 0);
+
+    if(conf->upstream.ssl_asynch && !conf->ssl) {
+        conf->ssl = 1;
+    }
+
     if (conf->ssl && ngx_http_grpc_set_ssl(cf, conf) != NGX_OK) {
         return NGX_CONF_ERROR;
     }
@@ -4880,6 +4897,7 @@ ngx_http_grpc_set_ssl(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *glcf)
     }

     glcf->upstream.ssl->log = cf->log;
+    glcf->upstream.ssl->asynch = glcf->upstream.ssl_asynch;

     if (ngx_ssl_create(glcf->upstream.ssl, glcf->ssl_protocols, NULL)
         != NGX_OK)
diff --git a/src/http/modules/ngx_http_proxy_module.c b/src/http/modules/ngx_http_proxy_module.c
index 7c4061c02..97158b1f2 100644
--- a/src/http/modules/ngx_http_proxy_module.c
+++ b/src/http/modules/ngx_http_proxy_module.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -685,6 +686,13 @@ static ngx_command_t  ngx_http_proxy_commands[] = {

 #if (NGX_HTTP_SSL)

+    { ngx_string("proxy_ssl_asynch"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_proxy_loc_conf_t, upstream.ssl_asynch),
+      NULL },
+
     { ngx_string("proxy_ssl_session_reuse"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
       ngx_conf_set_flag_slot,
@@ -3395,6 +3403,7 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)
     conf->upstream.intercept_errors = NGX_CONF_UNSET;

 #if (NGX_HTTP_SSL)
+    conf->upstream.ssl_asynch = NGX_CONF_UNSET;
     conf->upstream.ssl_session_reuse = NGX_CONF_UNSET;
     conf->upstream.ssl_name = NGX_CONF_UNSET_PTR;
     conf->upstream.ssl_server_name = NGX_CONF_UNSET;
@@ -3720,6 +3729,9 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)

 #if (NGX_HTTP_SSL)

+    ngx_conf_merge_value(conf->upstream.ssl_asynch,
+                              prev->upstream.ssl_asynch, 0);
+
     ngx_conf_merge_value(conf->upstream.ssl_session_reuse,
                               prev->upstream.ssl_session_reuse, 1);

@@ -3752,6 +3764,10 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_ptr_value(conf->ssl_conf_commands,
                               prev->ssl_conf_commands, NULL);

+    if(conf->upstream.ssl_asynch && !conf->ssl) {
+        conf->ssl = 1;
+    }
+
     if (conf->ssl && ngx_http_proxy_set_ssl(cf, conf) != NGX_OK) {
         return NGX_CONF_ERROR;
     }
@@ -4930,6 +4946,8 @@ ngx_http_proxy_set_ssl(ngx_conf_t *cf, ngx_http_proxy_loc_conf_t *plcf)

     plcf->upstream.ssl->log = cf->log;

+    plcf->upstream.ssl->asynch = plcf->upstream.ssl_asynch;
+
     if (ngx_ssl_create(plcf->upstream.ssl, plcf->ssl_protocols, NULL)
         != NGX_OK)
     {
diff --git a/src/http/modules/ngx_http_ssl_module.c b/src/http/modules/ngx_http_ssl_module.c
index d74d46094..2ce971c26 100644
--- a/src/http/modules/ngx_http_ssl_module.c
+++ b/src/http/modules/ngx_http_ssl_module.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -41,6 +42,8 @@ static ngx_int_t ngx_http_ssl_compile_certificates(ngx_conf_t *cf,

 static char *ngx_http_ssl_enable(ngx_conf_t *cf, ngx_command_t *cmd,
     void *conf);
+static char *ngx_http_ssl_enable_asynch(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
 static char *ngx_http_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd,
     void *conf);
 static char *ngx_http_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd,
@@ -100,6 +103,13 @@ static ngx_command_t  ngx_http_ssl_commands[] = {
       offsetof(ngx_http_ssl_srv_conf_t, enable),
       &ngx_http_ssl_deprecated },

+    { ngx_string("ssl_asynch"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,
+      ngx_http_ssl_enable_asynch,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, enable_asynch),
+      NULL },
+
     { ngx_string("ssl_certificate"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
       ngx_conf_set_str_array_slot,
@@ -156,6 +166,27 @@ static ngx_command_t  ngx_http_ssl_commands[] = {
       offsetof(ngx_http_ssl_srv_conf_t, buffer_size),
       NULL },

+    { ngx_string("ssl_max_pipelines"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, max_pipelines),
+      NULL },
+
+    { ngx_string("ssl_split_send_fragment"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, split_send_fragment),
+      NULL },
+
+    { ngx_string("ssl_max_send_fragment"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, max_send_fragment),
+      NULL },
+
     { ngx_string("ssl_verify_client"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
       ngx_conf_set_enum_slot,
@@ -580,10 +611,14 @@ ngx_http_ssl_create_srv_conf(ngx_conf_t *cf)
      */

     sscf->enable = NGX_CONF_UNSET;
+    sscf->enable_asynch = NGX_CONF_UNSET;
     sscf->prefer_server_ciphers = NGX_CONF_UNSET;
     sscf->early_data = NGX_CONF_UNSET;
     sscf->reject_handshake = NGX_CONF_UNSET;
     sscf->buffer_size = NGX_CONF_UNSET_SIZE;
+    sscf->max_pipelines = NGX_CONF_UNSET_SIZE;
+    sscf->split_send_fragment = NGX_CONF_UNSET_SIZE;
+    sscf->max_send_fragment = NGX_CONF_UNSET_SIZE;
     sscf->verify = NGX_CONF_UNSET_UINT;
     sscf->verify_depth = NGX_CONF_UNSET_UINT;
     sscf->certificates = NGX_CONF_UNSET_PTR;
@@ -622,6 +657,17 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
         }
     }

+    if (conf->enable_asynch == NGX_CONF_UNSET) {
+        if (prev->enable_asynch == NGX_CONF_UNSET) {
+            conf->enable_asynch = 0;
+
+        } else {
+            conf->enable_asynch = prev->enable_asynch;
+            conf->file = prev->file;
+            conf->line = prev->line;
+        }
+    }
+
     ngx_conf_merge_value(conf->session_timeout,
                          prev->session_timeout, 300);

@@ -638,6 +684,10 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size,
                          NGX_SSL_BUFSIZE);

+    ngx_conf_merge_size_value(conf->max_pipelines, prev->max_pipelines, 0);
+    ngx_conf_merge_size_value(conf->split_send_fragment, prev->split_send_fragment, 0);
+    ngx_conf_merge_size_value(conf->max_send_fragment, prev->max_send_fragment, 0);
+
     ngx_conf_merge_uint_value(conf->verify, prev->verify, 0);
     ngx_conf_merge_uint_value(conf->verify_depth, prev->verify_depth, 1);

@@ -705,6 +755,9 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
             return NGX_CONF_ERROR;
         }

+        conf->ssl.asynch = conf->enable_asynch;
+
+
     } else if (conf->certificates) {

         if (conf->certificate_keys == NULL
@@ -793,6 +846,9 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
     }

     conf->ssl.buffer_size = conf->buffer_size;
+    conf->ssl.max_pipelines = conf->max_pipelines;
+    conf->ssl.split_send_fragment = conf->split_send_fragment;
+    conf->ssl.max_send_fragment = conf->max_send_fragment;

     if (conf->verify) {

@@ -1010,6 +1066,37 @@ ngx_http_ssl_enable(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
     return NGX_CONF_OK;
 }

+static char *
+ngx_http_ssl_enable_asynch(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_http_ssl_srv_conf_t *sscf = conf;
+
+    char  *rv;
+
+    ngx_flag_t       *pssl, *pssl_asynch;
+
+    rv = ngx_conf_set_flag_slot(cf, cmd, conf);
+
+    if (rv != NGX_CONF_OK) {
+        return rv;
+    }
+
+    /* If ssl_asynch on is configured, then ssl on is configured by default
+     * This will align 'ssl_asynch on;' and 'listen port ssl' diretives
+     * */
+    pssl = (ngx_flag_t *) ((char *)conf + offsetof(ngx_http_ssl_srv_conf_t, enable));
+    pssl_asynch = (ngx_flag_t *) ((char *)conf + cmd->offset);
+
+    if(*pssl_asynch && *pssl != 1) {
+        *pssl = *pssl_asynch;
+    }
+
+    sscf->file = cf->conf_file->file.name.data;
+    sscf->line = cf->conf_file->line;
+
+    return NGX_CONF_OK;
+}
+

 static char *
 ngx_http_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
diff --git a/src/http/modules/ngx_http_ssl_module.h b/src/http/modules/ngx_http_ssl_module.h
index 7ab0f7eae..a6df4b5f8 100644
--- a/src/http/modules/ngx_http_ssl_module.h
+++ b/src/http/modules/ngx_http_ssl_module.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -17,6 +18,8 @@
 typedef struct {
     ngx_flag_t                      enable;

+    ngx_flag_t                      enable_asynch;
+
     ngx_ssl_t                       ssl;

     ngx_flag_t                      prefer_server_ciphers;
@@ -29,6 +32,9 @@ typedef struct {
     ngx_uint_t                      verify_depth;

     size_t                          buffer_size;
+    size_t                          max_pipelines;
+    size_t                          split_send_fragment;
+    size_t                          max_send_fragment;

     ssize_t                         builtin_session_cache;

diff --git a/src/http/modules/ngx_http_upstream_keepalive_module.c b/src/http/modules/ngx_http_upstream_keepalive_module.c
index 1a4dfd776..26bd567dd 100644
--- a/src/http/modules/ngx_http_upstream_keepalive_module.c
+++ b/src/http/modules/ngx_http_upstream_keepalive_module.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Maxim Dounin
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -288,6 +289,9 @@ found:
     c->log = pc->log;
     c->read->log = pc->log;
     c->write->log = pc->log;
+#if (NGX_SSL)
+    c->async->log = pc->log;
+#endif
     c->pool->log = pc->log;

     if (c->read->timer_set) {
@@ -386,6 +390,11 @@ ngx_http_upstream_free_keepalive_peer(ngx_peer_connection_t *pc, void *data,
     if (c->write->timer_set) {
         ngx_del_timer(c->write);
     }
+#if (NGX_SSL)
+    if (c->async->timer_set) {
+        ngx_del_timer(c->async);
+    }
+#endif

     c->write->handler = ngx_http_upstream_keepalive_dummy_handler;
     c->read->handler = ngx_http_upstream_keepalive_close_handler;
@@ -395,6 +404,9 @@ ngx_http_upstream_free_keepalive_peer(ngx_peer_connection_t *pc, void *data,
     c->log = ngx_cycle->log;
     c->read->log = ngx_cycle->log;
     c->write->log = ngx_cycle->log;
+#if (NGX_SSL)
+    c->async->log = ngx_cycle->log;
+#endif
     c->pool->log = ngx_cycle->log;

     item->socklen = pc->socklen;
diff --git a/src/http/ngx_http.c b/src/http/ngx_http.c
index 73c08d593..be4a5ad40 100644
--- a/src/http/ngx_http.c
+++ b/src/http/ngx_http.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -1232,6 +1233,7 @@ ngx_http_add_addresses(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,
     ngx_http_conf_addr_t  *addr;
 #if (NGX_HTTP_SSL)
     ngx_uint_t             ssl;
+    ngx_uint_t             asynch;
 #endif
 #if (NGX_HTTP_V2)
     ngx_uint_t             http2;
@@ -1267,6 +1269,7 @@ ngx_http_add_addresses(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,

 #if (NGX_HTTP_SSL)
         ssl = lsopt->ssl || addr[i].opt.ssl;
+        asynch = lsopt->asynch || addr[i].opt.asynch;
 #endif
 #if (NGX_HTTP_V2)
         http2 = lsopt->http2 || addr[i].opt.http2;
@@ -1303,6 +1306,7 @@ ngx_http_add_addresses(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,
         addr[i].opt.proxy_protocol = proxy_protocol;
 #if (NGX_HTTP_SSL)
         addr[i].opt.ssl = ssl;
+        addr[i].opt.asynch = asynch;
 #endif
 #if (NGX_HTTP_V2)
         addr[i].opt.http2 = http2;
@@ -1833,6 +1837,7 @@ ngx_http_add_addrs(ngx_conf_t *cf, ngx_http_port_t *hport,
         addrs[i].conf.default_server = addr[i].default_server;
 #if (NGX_HTTP_SSL)
         addrs[i].conf.ssl = addr[i].opt.ssl;
+        addrs[i].conf.asynch = addr[i].opt.asynch;
 #endif
 #if (NGX_HTTP_V2)
         addrs[i].conf.http2 = addr[i].opt.http2;
@@ -1898,6 +1903,7 @@ ngx_http_add_addrs6(ngx_conf_t *cf, ngx_http_port_t *hport,
         addrs6[i].conf.default_server = addr[i].default_server;
 #if (NGX_HTTP_SSL)
         addrs6[i].conf.ssl = addr[i].opt.ssl;
+        addrs6[i].conf.asynch = addr[i].opt.asynch;
 #endif
 #if (NGX_HTTP_V2)
         addrs6[i].conf.http2 = addr[i].opt.http2;
diff --git a/src/http/ngx_http_core_module.c b/src/http/ngx_http_core_module.c
index c7463dcdc..159470121 100644
--- a/src/http/ngx_http_core_module.c
+++ b/src/http/ngx_http_core_module.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -4083,6 +4084,19 @@ ngx_http_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
 #endif
         }

+        if (ngx_strcmp(value[n].data, "asynch") == 0) {
+#if (NGX_HTTP_SSL)
+            lsopt.ssl = 1;
+            lsopt.asynch = 1;
+            continue;
+#else
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "the \"asynch\" parameter requires "
+                               "ngx_http_ssl_module");
+            return NGX_CONF_ERROR;
+#endif
+        }
+
         if (ngx_strcmp(value[n].data, "http2") == 0) {
 #if (NGX_HTTP_V2)
             lsopt.http2 = 1;
diff --git a/src/http/ngx_http_core_module.h b/src/http/ngx_http_core_module.h
index 004a98eef..698d509d3 100644
--- a/src/http/ngx_http_core_module.h
+++ b/src/http/ngx_http_core_module.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -74,6 +75,7 @@ typedef struct {
     unsigned                   bind:1;
     unsigned                   wildcard:1;
     unsigned                   ssl:1;
+    unsigned                   asynch:1;
     unsigned                   http2:1;
 #if (NGX_HAVE_INET6)
     unsigned                   ipv6only:1;
@@ -236,6 +238,7 @@ struct ngx_http_addr_conf_s {
     ngx_http_virtual_names_t  *virtual_names;

     unsigned                   ssl:1;
+    unsigned                   asynch:1;
     unsigned                   http2:1;
     unsigned                   proxy_protocol:1;
 };
diff --git a/src/http/ngx_http_request.c b/src/http/ngx_http_request.c
index 013b7158e..12d17ee5d 100644
--- a/src/http/ngx_http_request.c
+++ b/src/http/ngx_http_request.c
@@ -2,11 +2,13 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


 #include <ngx_config.h>
 #include <ngx_core.h>
+#include <ngx_ssl_engine.h>
 #include <ngx_http.h>


@@ -340,6 +342,14 @@ ngx_http_init_connection(ngx_connection_t *c)
     if (sscf->enable || hc->addr_conf->ssl) {
         hc->ssl = 1;
         c->log->action = "SSL handshaking";
+        c->ssl_enabled = 1;
+
+        c->asynch = hc->addr_conf->asynch;
+
+        if (ngx_use_ssl_engine && ngx_ssl_engine_enable_heuristic_polling) {
+            (void) ngx_atomic_fetch_add(ngx_ssl_active, 1);
+        }
+
         rev->handler = ngx_http_ssl_handshake;
     }
     }
@@ -447,9 +457,21 @@ ngx_http_wait_request_handler(ngx_event_t *rev)
          * We are trying to not hold c->buffer's memory for an idle connection.
          */

-        if (ngx_pfree(c->pool, b->start) == NGX_OK) {
-            b->start = NULL;
+        /* For the Async implementation we need the same buffer to be used
+         * again on any async calls that have not completed.
+         * As such we need to turn off this optimisation if an async request
+         * is still in progress.
+         */
+
+#if (NGX_HTTP_SSL)
+        if ((c->asynch && !ngx_ssl_waiting_for_async(c)) || !c->asynch) {
+#endif
+            if (ngx_pfree(c->pool, b->start) == NGX_OK) {
+                b->start = NULL;
+            }
+#if (NGX_HTTP_SSL)
         }
+#endif

         return;
     }
@@ -1607,8 +1629,8 @@ ngx_http_alloc_large_header_buffer(ngx_http_request_t *r,
     cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);

     if (r->state != 0
-        && (size_t) (r->header_in->pos - old)
-                                     >= cscf->large_client_header_buffers.size)
+        && (size_t) (unsigned) (r->header_in->pos - old) \
+                  >= cscf->large_client_header_buffers.size)
     {
         return NGX_DECLINED;
     }
@@ -3166,52 +3188,62 @@ ngx_http_set_keepalive(ngx_http_request_t *r)
      * c->pool and are freed too.
      */

-    b = c->buffer;
-
-    if (ngx_pfree(c->pool, b->start) == NGX_OK) {
+    /* For the Async implementation we need the same buffer to be used
+     * again on any async calls that have not completed.
+     * As such we need to turn off this optimisation if an async request
+     * is still in progress.
+     */

-        /*
-         * the special note for ngx_http_keepalive_handler() that
-         * c->buffer's memory was freed
-         */
+#if (NGX_HTTP_SSL)
+    if ((c->asynch && !ngx_ssl_waiting_for_async(c)) || !c->asynch) {
+#endif
+        b = c->buffer;

-        b->pos = NULL;
+        if (ngx_pfree(c->pool, b->start) == NGX_OK) {

-    } else {
-        b->pos = b->start;
-        b->last = b->start;
-    }
+            /*
+             * the special note for ngx_http_keepalive_handler() that
+             * c->buffer's memory was freed
+             */

-    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0, "hc free: %p",
-                   hc->free);
+            b->pos = NULL;

-    if (hc->free) {
-        for (cl = hc->free; cl; /* void */) {
-            ln = cl;
-            cl = cl->next;
-            ngx_pfree(c->pool, ln->buf->start);
-            ngx_free_chain(c->pool, ln);
+        } else {
+            b->pos = b->start;
+            b->last = b->start;
         }

-        hc->free = NULL;
-    }
+        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0, "hc free: %p",
+                       hc->free);

-    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0, "hc busy: %p %i",
-                   hc->busy, hc->nbusy);
+        if (hc->free) {
+            for (cl = hc->free; cl; /* void */) {
+                ln = cl;
+                cl = cl->next;
+                ngx_pfree(c->pool, ln->buf->start);
+                ngx_free_chain(c->pool, ln);
+            }

-    if (hc->busy) {
-        for (cl = hc->busy; cl; /* void */) {
-            ln = cl;
-            cl = cl->next;
-            ngx_pfree(c->pool, ln->buf->start);
-            ngx_free_chain(c->pool, ln);
+            hc->free = NULL;
         }

-        hc->busy = NULL;
-        hc->nbusy = 0;
-    }
+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0, "hc busy: %p %i",
+                           hc->busy, hc->nbusy);

+        if (hc->busy) {
+            for (cl = hc->busy; cl; /* void */) {
+                ln = cl;
+                cl = cl->next;
+                ngx_pfree(c->pool, ln->buf->start);
+                ngx_free_chain(c->pool, ln);
+            }
+
+            hc->busy = NULL;
+            hc->nbusy = 0;
+        }
 #if (NGX_HTTP_SSL)
+    }
+
     if (c->ssl) {
         ngx_ssl_free_buffer(c);
     }
@@ -3220,6 +3252,14 @@ ngx_http_set_keepalive(ngx_http_request_t *r)
     rev->handler = ngx_http_keepalive_handler;

     if (wev->active && (ngx_event_flags & NGX_USE_LEVEL_EVENT)) {
+#if (NGX_HTTP_SSL)
+        if (c->asynch && ngx_del_async_conn) {
+            if (c->num_async_fds) {
+                ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                c->num_async_fds--;
+            }
+        }
+#endif
         if (ngx_del_event(wev, NGX_WRITE_EVENT, 0) != NGX_OK) {
             ngx_http_close_connection(c);
             return;
@@ -3344,14 +3384,25 @@ ngx_http_keepalive_handler(ngx_event_t *rev)
          * c->buffer's memory for a keepalive connection.
          */

-        if (ngx_pfree(c->pool, b->start) == NGX_OK) {
+        /* For the Asynch implementation we need the same buffer to be used
+         * on subsequent read requests. As such we need to turn off this optimisation that
+         * frees the buffer between invocations as may end up with a buffer that is at a
+         * different address */

-            /*
-             * the special note that c->buffer's memory was freed
-             */
+#if (NGX_HTTP_SSL)
+        if ((c->asynch && !ngx_ssl_waiting_for_async(c)) || !c->asynch) {
+#endif
+            if (ngx_pfree(c->pool, b->start) == NGX_OK) {

-            b->pos = NULL;
+                /*
+                 * the special note that c->buffer's memory was freed
+                 */
+
+                b->pos = NULL;
+            }
+#if (NGX_HTTP_SSL)
         }
+#endif

         return;
     }
@@ -3441,6 +3492,14 @@ ngx_http_set_lingering_close(ngx_connection_t *c)
     wev->handler = ngx_http_empty_handler;

     if (wev->active && (ngx_event_flags & NGX_USE_LEVEL_EVENT)) {
+#if (NGX_HTTP_SSL)
+        if (c->asynch && ngx_del_async_conn) {
+            if (c->num_async_fds) {
+                ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                c->num_async_fds--;
+            }
+        }
+#endif
         if (ngx_del_event(wev, NGX_WRITE_EVENT, 0) != NGX_OK) {
             ngx_http_close_request(r, 0);
             return;
@@ -3784,6 +3843,14 @@ ngx_http_close_connection(ngx_connection_t *c)

     ngx_close_connection(c);

+#if (NGX_HTTP_SSL)
+    if (c->ssl_enabled && ngx_use_ssl_engine
+        && ngx_ssl_engine_enable_heuristic_polling) {
+        (void) ngx_atomic_fetch_add(ngx_ssl_active, -1);
+        ngx_ssl_engine_heuristic_poll(c->log);
+    }
+#endif
+
     ngx_destroy_pool(pool);
 }

diff --git a/src/http/ngx_http_upstream.c b/src/http/ngx_http_upstream.c
index ded833c41..af06ca0e4 100644
--- a/src/http/ngx_http_upstream.c
+++ b/src/http/ngx_http_upstream.c
@@ -2,13 +2,14 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


 #include <ngx_config.h>
 #include <ngx_core.h>
 #include <ngx_http.h>
-
+#include <ngx_ssl_engine.h>

 #if (NGX_HTTP_CACHE)
 static ngx_int_t ngx_http_upstream_cache(ngx_http_request_t *r,
@@ -957,7 +958,8 @@ ngx_http_upstream_cache(ngx_http_request_t *r, ngx_http_upstream_t *u)

     case NGX_DECLINED:

-        if ((size_t) (u->buffer.end - u->buffer.start) < u->conf->buffer_size) {
+        if ((size_t) (unsigned) (u->buffer.end - u->buffer.start) \
+            < u->conf->buffer_size) {
             u->buffer.start = NULL;

         } else {
@@ -1336,7 +1338,14 @@ ngx_http_upstream_check_broken_connection(ngx_http_request_t *r,
         if ((ngx_event_flags & NGX_USE_LEVEL_EVENT) && ev->active) {

             event = ev->write ? NGX_WRITE_EVENT : NGX_READ_EVENT;
-
+#if (NGX_HTTP_SSL)
+            if (c->asynch && ngx_del_async_conn) {
+                if (c->num_async_fds) {
+                    ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                    c->num_async_fds--;
+                }
+            }
+#endif
             if (ngx_del_event(ev, event, 0) != NGX_OK) {
                 ngx_http_upstream_finalize_request(r, u,
                                                NGX_HTTP_INTERNAL_SERVER_ERROR);
@@ -1463,7 +1472,14 @@ ngx_http_upstream_check_broken_connection(ngx_http_request_t *r,
     if ((ngx_event_flags & NGX_USE_LEVEL_EVENT) && ev->active) {

         event = ev->write ? NGX_WRITE_EVENT : NGX_READ_EVENT;
-
+#if (NGX_HTTP_SSL)
+        if (c->asynch && ngx_del_async_conn) {
+            if (c->num_async_fds) {
+                ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                c->num_async_fds--;
+            }
+        }
+#endif
         if (ngx_del_event(ev, event, 0) != NGX_OK) {
             ngx_http_upstream_finalize_request(r, u,
                                                NGX_HTTP_INTERNAL_SERVER_ERROR);
@@ -1596,6 +1612,9 @@ ngx_http_upstream_connect(ngx_http_request_t *r, ngx_http_upstream_t *u)
     c->log = r->connection->log;
     c->pool->log = c->log;
     c->read->log = c->log;
+#if (NGX_SSL)
+    c->async->log = c->log;
+#endif
     c->write->log = c->log;

     /* init or reinit the ngx_output_chain() and ngx_chain_writer() contexts */
@@ -1726,6 +1745,10 @@ ngx_http_upstream_ssl_init_connection(ngx_http_request_t *r,

     r->connection->log->action = "SSL handshaking to upstream";

+    if (ngx_use_ssl_engine && ngx_ssl_engine_enable_heuristic_polling) {
+        (void) ngx_atomic_fetch_add(ngx_ssl_active, 1);
+    }
+
     rc = ngx_ssl_handshake(c);

     if (rc == NGX_AGAIN) {
@@ -1772,6 +1795,10 @@ ngx_http_upstream_ssl_handshake(ngx_http_request_t *r, ngx_http_upstream_t *u,
     long  rc;

     if (c->ssl->handshaked) {
+        if (c->asynch && r->connection->error) {
+            ngx_http_upstream_finalize_request(r, u, NGX_HTTP_CLIENT_CLOSED_REQUEST);
+            return;
+        }

         if (u->conf->ssl_verify) {
             rc = SSL_get_verify_result(c->ssl->connection);
@@ -1968,8 +1995,23 @@ ngx_http_upstream_ssl_certificate(ngx_http_request_t *r,
     return NGX_OK;
 }

-#endif

+static ngx_inline ngx_int_t
+ngx_http_upstream_ssl_check_want_async(ngx_http_request_t *r,
+    ngx_http_upstream_t *u)
+{
+    if (r->connection->error && u->peer.connection
+        && u->peer.connection->ssl && u->peer.connection->asynch
+        && SSL_in_init(u->peer.connection->ssl->connection)
+        && SSL_want_async(u->peer.connection->ssl->connection)) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "connection closed but need to wait until async job done");
+        return 1;
+    }
+    return 0;
+}
+
+#endif

 static ngx_int_t
 ngx_http_upstream_reinit(ngx_http_request_t *r, ngx_http_upstream_t *u)
@@ -4450,6 +4492,12 @@ ngx_http_upstream_finalize_request(ngx_http_request_t *r,
     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                    "finalize http upstream request: %i", rc);

+#if (NGX_HTTP_SSL)
+    if (ngx_http_upstream_ssl_check_want_async(r, u)) {
+        return;
+    }
+#endif
+
     if (u->cleanup == NULL) {
         /* the request was already finalized */
         ngx_http_finalize_request(r, NGX_DONE);
@@ -4554,7 +4602,8 @@ ngx_http_upstream_finalize_request(ngx_http_request_t *r,
             }
         }

-        ngx_http_file_cache_free(r->cache, u->pipe->temp_file);
+        if (u->pipe)
+            ngx_http_file_cache_free(r->cache, u->pipe->temp_file);
     }

 #endif
diff --git a/src/http/ngx_http_upstream.h b/src/http/ngx_http_upstream.h
index 3db7b0643..8489cd6fd 100644
--- a/src/http/ngx_http_upstream.h
+++ b/src/http/ngx_http_upstream.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -229,6 +230,7 @@ typedef struct {

 #if (NGX_HTTP_SSL || NGX_COMPAT)
     ngx_ssl_t                       *ssl;
+    ngx_flag_t                       ssl_asynch;
     ngx_flag_t                       ssl_session_reuse;

     ngx_http_complex_value_t        *ssl_name;
diff --git a/src/mail/ngx_mail.c b/src/mail/ngx_mail.c
index 890d8153a..b0d0f930c 100644
--- a/src/mail/ngx_mail.c
+++ b/src/mail/ngx_mail.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -404,6 +405,7 @@ ngx_mail_add_addrs(ngx_conf_t *cf, ngx_mail_port_t *mport,
         addrs[i].conf.ctx = addr[i].opt.ctx;
 #if (NGX_MAIL_SSL)
         addrs[i].conf.ssl = addr[i].opt.ssl;
+        addrs[i].conf.asynch = addr[i].opt.asynch;
 #endif
         addrs[i].conf.proxy_protocol = addr[i].opt.proxy_protocol;
         addrs[i].conf.addr_text = addr[i].opt.addr_text;
@@ -439,6 +441,7 @@ ngx_mail_add_addrs6(ngx_conf_t *cf, ngx_mail_port_t *mport,
         addrs6[i].conf.ctx = addr[i].opt.ctx;
 #if (NGX_MAIL_SSL)
         addrs6[i].conf.ssl = addr[i].opt.ssl;
+        addrs6[i].conf.asynch = addr[i].opt.asynch;
 #endif
         addrs6[i].conf.proxy_protocol = addr[i].opt.proxy_protocol;
         addrs6[i].conf.addr_text = addr[i].opt.addr_text;
diff --git a/src/mail/ngx_mail.h b/src/mail/ngx_mail.h
index e0c62b7ab..e891cc0df 100644
--- a/src/mail/ngx_mail.h
+++ b/src/mail/ngx_mail.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -37,6 +38,7 @@ typedef struct {
     unsigned                bind:1;
     unsigned                wildcard:1;
     unsigned                ssl:1;
+    unsigned                asynch:1;
 #if (NGX_HAVE_INET6)
     unsigned                ipv6only:1;
 #endif
@@ -58,6 +60,7 @@ typedef struct {
     ngx_str_t               addr_text;
     unsigned                ssl:1;
     unsigned                proxy_protocol:1;
+    ngx_uint_t              asynch;
 } ngx_mail_addr_conf_t;

 typedef struct {
diff --git a/src/mail/ngx_mail_core_module.c b/src/mail/ngx_mail_core_module.c
index 115671ca4..cdbcf1cd5 100644
--- a/src/mail/ngx_mail_core_module.c
+++ b/src/mail/ngx_mail_core_module.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -468,6 +469,23 @@ ngx_mail_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
 #endif
         }

+        if (ngx_strcmp(value[i].data, "asynch") == 0) {
+#if (NGX_MAIL_SSL)
+            ngx_mail_ssl_conf_t  *sslcf;
+            sslcf = ngx_mail_conf_get_module_srv_conf(cf, ngx_mail_ssl_module);
+            sslcf->asynch = 1;
+
+            ls->ssl = 1;
+            ls->asynch = 1;
+            continue;
+#else
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "the \"asynch\" parameter requires "
+                               "ngx_mail_ssl_module");
+            return NGX_CONF_ERROR;
+#endif
+        }
+
         if (ngx_strncmp(value[i].data, "so_keepalive=", 13) == 0) {

             if (ngx_strcmp(&value[i].data[13], "on") == 0) {
diff --git a/src/mail/ngx_mail_handler.c b/src/mail/ngx_mail_handler.c
index 246ba97cf..6e4c47891 100644
--- a/src/mail/ngx_mail_handler.c
+++ b/src/mail/ngx_mail_handler.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -134,6 +135,9 @@ ngx_mail_init_connection(ngx_connection_t *c)

 #if (NGX_MAIL_SSL)
     s->ssl = addr_conf->ssl;
+    if (addr_conf->asynch) {
+        c->asynch = addr_conf->asynch;
+    }
 #endif

     s->addr_text = &addr_conf->addr_text;
diff --git a/src/mail/ngx_mail_ssl_module.c b/src/mail/ngx_mail_ssl_module.c
index 2a1043e66..d9f16168b 100644
--- a/src/mail/ngx_mail_ssl_module.c
+++ b/src/mail/ngx_mail_ssl_module.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -25,6 +26,8 @@ static char *ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child);

 static char *ngx_mail_ssl_enable(ngx_conf_t *cf, ngx_command_t *cmd,
     void *conf);
+static char *ngx_mail_ssl_asynch(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
 static char *ngx_mail_ssl_starttls(ngx_conf_t *cf, ngx_command_t *cmd,
     void *conf);
 static char *ngx_mail_ssl_password_file(ngx_conf_t *cf, ngx_command_t *cmd,
@@ -83,6 +86,13 @@ static ngx_command_t  ngx_mail_ssl_commands[] = {
       offsetof(ngx_mail_ssl_conf_t, enable),
       &ngx_mail_ssl_deprecated },

+    { ngx_string("ssl_asynch"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,
+      ngx_mail_ssl_asynch,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_ssl_conf_t, asynch),
+      NULL },
+
     { ngx_string("starttls"),
       NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
       ngx_mail_ssl_starttls,
@@ -323,6 +333,7 @@ ngx_mail_ssl_create_conf(ngx_conf_t *cf)
      */

     scf->enable = NGX_CONF_UNSET;
+    scf->asynch = NGX_CONF_UNSET;
     scf->starttls = NGX_CONF_UNSET_UINT;
     scf->certificates = NGX_CONF_UNSET_PTR;
     scf->certificate_keys = NGX_CONF_UNSET_PTR;
@@ -350,6 +361,7 @@ ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_pool_cleanup_t  *cln;

     ngx_conf_merge_value(conf->enable, prev->enable, 0);
+    ngx_conf_merge_value(conf->asynch, prev->asynch, 0);
     ngx_conf_merge_uint_value(conf->starttls, prev->starttls,
                          NGX_MAIL_STARTTLS_OFF);

@@ -392,9 +404,9 @@ ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)

     if (conf->listen) {
         mode = "listen ... ssl";
-
     } else if (conf->enable) {
         mode = "ssl";
+        conf->ssl.asynch = conf->asynch;

     } else if (conf->starttls != NGX_MAIL_STARTTLS_OFF) {
         mode = "starttls";
@@ -572,6 +584,34 @@ ngx_mail_ssl_enable(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
 }


+static char *
+ngx_mail_ssl_asynch(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_mail_ssl_conf_t *scf = conf;
+
+    char  *rv;
+
+    rv = ngx_conf_set_flag_slot(cf, cmd, conf);
+
+    if (rv != NGX_CONF_OK) {
+        return rv;
+    }
+
+    /* If ssl_asynch on is configured, then ssl on is configured by default
+     * This will align 'ssl_asynch on;' and 'listen port ssl' diretives
+     * */
+
+    if(scf->asynch && (scf->enable != 1)) {
+        scf->enable = scf->asynch;
+    }
+
+    scf->file = cf->conf_file->file.name.data;
+    scf->line = cf->conf_file->line;
+
+    return NGX_CONF_OK;
+}
+
+
 static char *
 ngx_mail_ssl_starttls(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
 {
diff --git a/src/mail/ngx_mail_ssl_module.h b/src/mail/ngx_mail_ssl_module.h
index a0a611317..ca8c1e256 100644
--- a/src/mail/ngx_mail_ssl_module.h
+++ b/src/mail/ngx_mail_ssl_module.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -21,6 +22,7 @@

 typedef struct {
     ngx_flag_t       enable;
+    ngx_flag_t       asynch;
     ngx_flag_t       prefer_server_ciphers;

     ngx_ssl_t        ssl;
diff --git a/src/os/unix/ngx_process_cycle.c b/src/os/unix/ngx_process_cycle.c
index 07cd05e80..0d028fc1c 100644
--- a/src/os/unix/ngx_process_cycle.c
+++ b/src/os/unix/ngx_process_cycle.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -9,8 +10,12 @@
 #include <ngx_core.h>
 #include <ngx_event.h>
 #include <ngx_channel.h>
+#include <ngx_ssl_engine.h>
+#include <openssl/rand.h>


+pthread_mutex_t queue_lock;
+
 static void ngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t n,
     ngx_int_t type);
 static void ngx_start_cache_manager_processes(ngx_cycle_t *cycle,
@@ -210,6 +215,7 @@ ngx_master_process_cycle(ngx_cycle_t *cycle)

         if (ngx_reconfigure) {
             ngx_reconfigure = 0;
+            ngx_ssl_engine_reload_processed = 0;

             if (ngx_new_binary) {
                 ngx_start_worker_processes(cycle, ccf->worker_processes,
@@ -312,6 +318,7 @@ ngx_single_process_cycle(ngx_cycle_t *cycle)

         if (ngx_reconfigure) {
             ngx_reconfigure = 0;
+            ngx_ssl_engine_reload_processed = 0;
             ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "reconfiguring");

             cycle = ngx_init_cycle(cycle);
@@ -595,6 +602,13 @@ ngx_reap_children(ngx_cycle_t *cycle)
                 && !ngx_terminate
                 && !ngx_quit)
             {
+#if (NGX_SSL)
+                /* Delay added to give Quickassist Driver time to cleanup
+                * if worker exit with non-zero code. */
+                if(ngx_processes[i].status != 0) {
+                    usleep(2000000);
+                }
+#endif
                 if (ngx_spawn_process(cycle, ngx_processes[i].proc,
                                       ngx_processes[i].data,
                                       ngx_processes[i].name, i)
@@ -694,7 +708,6 @@ ngx_master_process_exit(ngx_cycle_t *cycle)
     exit(0);
 }

-
 static void
 ngx_worker_process_cycle(ngx_cycle_t *cycle, void *data)
 {
@@ -705,13 +718,25 @@ ngx_worker_process_cycle(ngx_cycle_t *cycle, void *data)

     ngx_worker_process_init(cycle, worker);

+    if(ngx_ssl_engine_init) {
+        ngx_ssl_engine_init(cycle);
+    }
+    if (pthread_mutex_init(&queue_lock, NULL) != 0) {
+	    fprintf(stderr, "\n mutex init has failed\n");
+    }
+
     ngx_setproctitle("worker process");

     for ( ;; ) {

         if (ngx_exiting) {
+            if(ngx_ssl_engine_release) {
+                ngx_ssl_engine_release(cycle);
+            }
+
             if (ngx_event_no_timers_left() == NGX_OK) {
                 ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "exiting");
+
                 ngx_worker_process_exit(cycle);
             }
         }
@@ -760,6 +785,18 @@ ngx_worker_process_init(ngx_cycle_t *cycle, ngx_int_t worker)
     ngx_core_conf_t  *ccf;
     ngx_listening_t  *ls;

+    if (worker >= 0) {
+        cpu_affinity = ngx_get_cpu_affinity(worker);
+
+        if (cpu_affinity) {
+            ngx_setaffinity(cpu_affinity, cycle->log);
+        }
+    }
+
+#if (NGX_OPENSSL)
+        ngx_ssl_conf_load(cycle->log);
+#endif
+
     if (ngx_set_environment(cycle, NULL) == NULL) {
         /* fatal */
         exit(2);
@@ -850,14 +887,6 @@ ngx_worker_process_init(ngx_cycle_t *cycle, ngx_int_t worker)
 #endif
     }

-    if (worker >= 0) {
-        cpu_affinity = ngx_get_cpu_affinity(worker);
-
-        if (cpu_affinity) {
-            ngx_setaffinity(cpu_affinity, cycle->log);
-        }
-    }
-
 #if (NGX_HAVE_PR_SET_DUMPABLE)

     /* allow coredump after setuid() in Linux 2.4.x */
@@ -1018,6 +1047,8 @@ ngx_channel_handler(ngx_event_t *ev)
         return;
     }

+    ngx_memzero(&ch, sizeof(ngx_channel_t));
+
     c = ev->data;

     ngx_log_debug0(NGX_LOG_DEBUG_CORE, ev->log, 0, "channel handler");
@@ -1031,6 +1062,14 @@ ngx_channel_handler(ngx_event_t *ev)
         if (n == NGX_ERROR) {

             if (ngx_event_flags & NGX_USE_EPOLL_EVENT) {
+#if (NGX_SSL)
+                if (c->asynch && ngx_del_async_conn) {
+                    if (c->num_async_fds) {
+                        ngx_del_async_conn(c, NGX_DISABLE_EVENT);
+                        c->num_async_fds--;
+                    }
+                }
+#endif
                 ngx_del_conn(c, 0);
             }

diff --git a/src/stream/ngx_stream.c b/src/stream/ngx_stream.c
index 3304c843c..caaf153c6 100644
--- a/src/stream/ngx_stream.c
+++ b/src/stream/ngx_stream.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Roman Arutyunyan
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -573,8 +574,9 @@ ngx_stream_add_addrs(ngx_conf_t *cf, ngx_stream_port_t *stport,
         addrs[i].addr = sin->sin_addr.s_addr;

         addrs[i].conf.ctx = addr[i].opt.ctx;
-#if (NGX_STREAM_SSL)
         addrs[i].conf.ssl = addr[i].opt.ssl;
+#if (NGX_STREAM_SSL)
+        addrs[i].conf.asynch = addr[i].opt.asynch;
 #endif
         addrs[i].conf.proxy_protocol = addr[i].opt.proxy_protocol;
         addrs[i].conf.addr_text = addr[i].opt.addr_text;
@@ -608,8 +610,9 @@ ngx_stream_add_addrs6(ngx_conf_t *cf, ngx_stream_port_t *stport,
         addrs6[i].addr6 = sin6->sin6_addr;

         addrs6[i].conf.ctx = addr[i].opt.ctx;
-#if (NGX_STREAM_SSL)
         addrs6[i].conf.ssl = addr[i].opt.ssl;
+#if (NGX_STREAM_SSL)
+        addrs6[i].conf.asynch = addr[i].opt.asynch;
 #endif
         addrs6[i].conf.proxy_protocol = addr[i].opt.proxy_protocol;
         addrs6[i].conf.addr_text = addr[i].opt.addr_text;
diff --git a/src/stream/ngx_stream.h b/src/stream/ngx_stream.h
index 46c362296..092c7851f 100644
--- a/src/stream/ngx_stream.h
+++ b/src/stream/ngx_stream.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Roman Arutyunyan
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -25,7 +26,6 @@ typedef struct ngx_stream_session_s  ngx_stream_session_t;
 #include <ngx_stream_upstream.h>
 #include <ngx_stream_upstream_round_robin.h>

-
 #define NGX_STREAM_OK                        200
 #define NGX_STREAM_BAD_REQUEST               400
 #define NGX_STREAM_FORBIDDEN                 403
@@ -51,6 +51,9 @@ typedef struct {
     unsigned                       bind:1;
     unsigned                       wildcard:1;
     unsigned                       ssl:1;
+#if (NGX_STREAM_SSL)
+    unsigned                       asynch:1;
+#endif
 #if (NGX_HAVE_INET6)
     unsigned                       ipv6only:1;
 #endif
@@ -76,6 +79,9 @@ typedef struct {
     ngx_stream_conf_ctx_t         *ctx;
     ngx_str_t                      addr_text;
     unsigned                       ssl:1;
+#if (NGX_STREAM_SSL)
+    unsigned                       asynch:1;
+#endif
     unsigned                       proxy_protocol:1;
 } ngx_stream_addr_conf_t;

diff --git a/src/stream/ngx_stream_core_module.c b/src/stream/ngx_stream_core_module.c
index d96d27ab5..c8c13ecc5 100644
--- a/src/stream/ngx_stream_core_module.c
+++ b/src/stream/ngx_stream_core_module.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Roman Arutyunyan
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -760,6 +761,24 @@ ngx_stream_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
 #endif
         }

+        if (ngx_strcmp(value[i].data, "asynch") == 0) {
+#if (NGX_STREAM_SSL)
+            ngx_stream_ssl_conf_t  *sslcf;
+            sslcf = ngx_stream_conf_get_module_srv_conf(cf,
+                                                        ngx_stream_ssl_module);
+            sslcf->asynch = 1;
+
+            ls->ssl = 1;
+            ls->asynch = 1;
+            continue;
+#else
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "the \"asynch\" parameter requires "
+                               "ngx_stream_ssl_module");
+            return NGX_CONF_ERROR;
+#endif
+        }
+
         if (ngx_strncmp(value[i].data, "so_keepalive=", 13) == 0) {

             if (ngx_strcmp(&value[i].data[13], "on") == 0) {
@@ -869,6 +888,10 @@ ngx_stream_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
         if (ls->ssl) {
             return "\"ssl\" parameter is incompatible with \"udp\"";
         }
+
+        if (ls->asynch) {
+            return "\"asynch\" parameter is incompatible with \"udp\"";
+        }
 #endif

         if (ls->so_keepalive) {
diff --git a/src/stream/ngx_stream_handler.c b/src/stream/ngx_stream_handler.c
index 669b6a18d..2d9adc481 100644
--- a/src/stream/ngx_stream_handler.c
+++ b/src/stream/ngx_stream_handler.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Roman Arutyunyan
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -9,7 +10,7 @@
 #include <ngx_core.h>
 #include <ngx_event.h>
 #include <ngx_stream.h>
-
+#include <ngx_ssl_engine.h>

 static void ngx_stream_log_session(ngx_stream_session_t *s);
 static void ngx_stream_close_connection(ngx_connection_t *c);
@@ -268,7 +269,6 @@ ngx_stream_proxy_protocol_handler(ngx_event_t *rev)
     }

     size = p - buf;
-
     if (c->recv(c, buf, size) != (ssize_t) size) {
         ngx_stream_finalize_session(s, NGX_STREAM_INTERNAL_SERVER_ERROR);
         return;
@@ -325,7 +325,7 @@ ngx_stream_log_session(ngx_stream_session_t *s)
 }


-static void
+void
 ngx_stream_close_connection(ngx_connection_t *c)
 {
     ngx_pool_t  *pool;
@@ -352,6 +352,14 @@ ngx_stream_close_connection(ngx_connection_t *c)

     ngx_close_connection(c);

+#if (NGX_STREAM_SSL)
+    if (c->ssl_enabled && ngx_use_ssl_engine
+        && ngx_ssl_engine_enable_heuristic_polling) {
+        (void) ngx_atomic_fetch_add(ngx_ssl_active, -1);
+        ngx_ssl_engine_heuristic_poll(c->log);
+    }
+#endif
+
     ngx_destroy_pool(pool);
 }

diff --git a/src/stream/ngx_stream_proxy_module.c b/src/stream/ngx_stream_proxy_module.c
index 934e7d8f2..9a8da3560 100644
--- a/src/stream/ngx_stream_proxy_module.c
+++ b/src/stream/ngx_stream_proxy_module.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Roman Arutyunyan
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -37,6 +38,7 @@ typedef struct {

 #if (NGX_STREAM_SSL)
     ngx_flag_t                       ssl_enable;
+    ngx_flag_t                       ssl_asynch;
     ngx_flag_t                       ssl_session_reuse;
     ngx_uint_t                       ssl_protocols;
     ngx_str_t                        ssl_ciphers;
@@ -262,6 +264,13 @@ static ngx_command_t  ngx_stream_proxy_commands[] = {
       offsetof(ngx_stream_proxy_srv_conf_t, ssl_enable),
       NULL },

+    { ngx_string("proxy_ssl_asynch"),
+      NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_STREAM_SRV_CONF_OFFSET,
+      offsetof(ngx_stream_proxy_srv_conf_t, ssl_asynch),
+      NULL },
+
     { ngx_string("proxy_ssl_session_reuse"),
       NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_FLAG,
       ngx_conf_set_flag_slot,
@@ -759,6 +768,9 @@ ngx_stream_proxy_connect(ngx_stream_session_t *s)
     pc->log = c->log;
     pc->pool = c->pool;
     pc->read->log = c->log;
+#if (NGX_SSL)
+    pc->async->log = c->log;
+#endif
     pc->write->log = c->log;

     if (rc != NGX_AGAIN) {
@@ -2089,6 +2101,7 @@ ngx_stream_proxy_create_srv_conf(ngx_conf_t *cf)

 #if (NGX_STREAM_SSL)
     conf->ssl_enable = NGX_CONF_UNSET;
+    conf->ssl_asynch = NGX_CONF_UNSET;
     conf->ssl_session_reuse = NGX_CONF_UNSET;
     conf->ssl_name = NGX_CONF_UNSET_PTR;
     conf->ssl_server_name = NGX_CONF_UNSET;
@@ -2150,6 +2163,8 @@ ngx_stream_proxy_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)

     ngx_conf_merge_value(conf->ssl_enable, prev->ssl_enable, 0);

+    ngx_conf_merge_value(conf->ssl_asynch, prev->ssl_asynch, 0);
+
     ngx_conf_merge_value(conf->ssl_session_reuse,
                               prev->ssl_session_reuse, 1);

@@ -2184,6 +2199,10 @@ ngx_stream_proxy_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_ptr_value(conf->ssl_conf_commands,
                               prev->ssl_conf_commands, NULL);

+    if(conf->ssl_asynch && !conf->ssl_enable) {
+        conf->ssl_enable = 1;
+    }
+
     if (conf->ssl_enable && ngx_stream_proxy_set_ssl(cf, conf) != NGX_OK) {
         return NGX_CONF_ERROR;
     }
@@ -2208,6 +2227,8 @@ ngx_stream_proxy_set_ssl(ngx_conf_t *cf, ngx_stream_proxy_srv_conf_t *pscf)

     pscf->ssl->log = cf->log;

+    pscf->ssl->asynch = pscf->ssl_asynch;
+
     if (ngx_ssl_create(pscf->ssl, pscf->ssl_protocols, NULL) != NGX_OK) {
         return NGX_ERROR;
     }
diff --git a/src/stream/ngx_stream_ssl_module.c b/src/stream/ngx_stream_ssl_module.c
index c5308322a..44755fdea 100644
--- a/src/stream/ngx_stream_ssl_module.c
+++ b/src/stream/ngx_stream_ssl_module.c
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -86,6 +87,13 @@ static ngx_conf_post_t  ngx_stream_ssl_conf_command_post =

 static ngx_command_t  ngx_stream_ssl_commands[] = {

+    { ngx_string("ssl_asynch"),
+      NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_STREAM_SRV_CONF_OFFSET,
+      offsetof(ngx_stream_ssl_conf_t, asynch),
+      NULL },
+
     { ngx_string("ssl_handshake_timeout"),
       NGX_STREAM_MAIN_CONF|NGX_STREAM_SRV_CONF|NGX_CONF_TAKE1,
       ngx_conf_set_msec_slot,
@@ -349,6 +357,8 @@ ngx_stream_ssl_handler(ngx_stream_session_t *s)
     if (c->ssl == NULL) {
         c->log->action = "SSL handshaking";

+        c->asynch = sslcf->ssl.asynch;
+
         rv = ngx_stream_ssl_init_connection(&sslcf->ssl, c);

         if (rv != NGX_OK) {
@@ -668,6 +678,7 @@ ngx_stream_ssl_create_conf(ngx_conf_t *cf)
      *     scf->shm_zone = NULL;
      */

+    scf->asynch = NGX_CONF_UNSET;
     scf->handshake_timeout = NGX_CONF_UNSET_MSEC;
     scf->certificates = NGX_CONF_UNSET_PTR;
     scf->certificate_keys = NGX_CONF_UNSET_PTR;
@@ -693,6 +704,8 @@ ngx_stream_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)

     ngx_pool_cleanup_t  *cln;

+    ngx_conf_merge_value(conf->asynch, prev->asynch, 0);
+
     ngx_conf_merge_msec_value(conf->handshake_timeout,
                          prev->handshake_timeout, 60000);

@@ -733,6 +746,7 @@ ngx_stream_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)


     conf->ssl.log = cf->log;
+    conf->ssl.asynch = conf->asynch;

     if (!conf->listen) {
         return NGX_CONF_OK;
diff --git a/src/stream/ngx_stream_ssl_module.h b/src/stream/ngx_stream_ssl_module.h
index e7c825e9b..95b72d648 100644
--- a/src/stream/ngx_stream_ssl_module.h
+++ b/src/stream/ngx_stream_ssl_module.h
@@ -2,6 +2,7 @@
 /*
  * Copyright (C) Igor Sysoev
  * Copyright (C) Nginx, Inc.
+ * Copyright (C) Intel, Inc.
  */


@@ -21,6 +22,8 @@ typedef struct {

     ngx_ssl_t        ssl;

+    ngx_flag_t       asynch;
+
     ngx_uint_t       listen;
     ngx_uint_t       protocols;

--
2.17.1

